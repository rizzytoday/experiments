<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flow Field</title>
<style>
* { margin:0; padding:0; box-sizing:border-box }
body { background: #08061a; overflow:hidden; cursor:crosshair }
canvas { display:block }
#controls {
  position:fixed; bottom:16px; right:16px; z-index:10;
  backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(136,102,221,0.1);
  font: 11px/1.6 monospace; border-radius: 14px;
  background: rgba(8,6,26,0.75); color: rgba(136,102,221,0.55);
  box-shadow: 0 4px 24px rgba(0,0,0,0.3); padding: 14px 18px;
  min-width: 190px;
}
#controls label { display:flex; justify-content:space-between; align-items:center; margin:5px 0 }
#controls span { min-width:42px; text-align:right; color:rgba(136,102,221,0.8) }
input[type=range] {
  -webkit-appearance:none; width:100px; height:3px;
  background:rgba(136,102,221,0.12); border-radius:2px; outline:none; margin:0 8px;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:12px; height:12px;
  background:#8866dd; border-radius:50%; cursor:pointer;
}
.hint { color:rgba(136,102,221,0.2); margin-top:10px; font-size:10px; line-height:1.5 }
#readout {
  position:fixed; bottom:16px; left:16px;
  font: 12px monospace; color: rgba(136,102,221,0.35); z-index:10;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="controls">
  <label>scale <input type="range" id="sScale" min="0.001" max="0.01" step="0.001" value="0.004"><span id="vScale">0.004</span></label>
  <label>count <input type="range" id="sCount" min="5000" max="20000" step="1000" value="12000"><span id="vCount">12000</span></label>
  <label>speed <input type="range" id="sSpeed" min="0.5" max="4" step="0.1" value="1.5"><span id="vSpeed">1.5</span></label>
  <div class="hint">space = pause &middot; r = reset</div>
</div>
<div id="readout"></div>
<script>
// --- Perlin noise (classic 3D, inline) ---
const perm = new Uint8Array(512);
const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
               [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
               [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
(function seedPerm() {
  const p = new Uint8Array(256);
  for (let i = 0; i < 256; i++) p[i] = i;
  for (let i = 255; i > 0; i--) {
    const j = (Math.random() * (i + 1)) | 0;
    const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
  }
  for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
})();

function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(a, b, t) { return a + t * (b - a); }
function dot3(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }

function noise(x, y, z) {
  const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
  x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
  const u = fade(x), v = fade(y), w = fade(z);
  const A = perm[X]+Y, AA = perm[A]+Z, AB = perm[A+1]+Z;
  const B = perm[X+1]+Y, BA = perm[B]+Z, BB = perm[B+1]+Z;
  return lerp(
    lerp(lerp(dot3(grad3[perm[AA]%12],x,y,z), dot3(grad3[perm[BA]%12],x-1,y,z),u),
         lerp(dot3(grad3[perm[AB]%12],x,y-1,z), dot3(grad3[perm[BB]%12],x-1,y-1,z),u),v),
    lerp(lerp(dot3(grad3[perm[AA+1]%12],x,y,z-1), dot3(grad3[perm[BA+1]%12],x-1,y,z-1),u),
         lerp(dot3(grad3[perm[AB+1]%12],x,y-1,z-1), dot3(grad3[perm[BB+1]%12],x-1,y-1,z-1),u),v),w);
}

// --- Setup ---
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;
let W = window.innerWidth, H = window.innerHeight;
const TWO_PI = Math.PI * 2;

function resize() {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// --- Particles ---
let maxCount = 20000;
let px = new Float32Array(maxCount);
let py = new Float32Array(maxCount);
let vx = new Float32Array(maxCount);
let vy = new Float32Array(maxCount);

function randomize(count) {
  for (let i = 0; i < count; i++) {
    px[i] = Math.random() * W;
    py[i] = Math.random() * H;
    vx[i] = 0; vy[i] = 0;
  }
}

// --- Controls ---
let noiseScale = 0.004, particleCount = 12000, speed = 1.5;
let paused = false, t = 0;
let mx = -9999, my = -9999;

const sScale = document.getElementById('sScale');
const sCount = document.getElementById('sCount');
const sSpeed = document.getElementById('sSpeed');
const vScale = document.getElementById('vScale');
const vCount = document.getElementById('vCount');
const vSpeed = document.getElementById('vSpeed');
const readout = document.getElementById('readout');

sScale.addEventListener('input', () => { noiseScale = +sScale.value; vScale.textContent = sScale.value; });
sCount.addEventListener('input', () => {
  const nv = +sCount.value;
  if (nv > particleCount) for (let i = particleCount; i < nv; i++) {
    px[i] = Math.random() * W; py[i] = Math.random() * H; vx[i] = 0; vy[i] = 0;
  }
  particleCount = nv; vCount.textContent = nv;
});
sSpeed.addEventListener('input', () => { speed = +sSpeed.value; vSpeed.textContent = sSpeed.value; });

randomize(particleCount);

// --- Input ---
window.addEventListener('mousemove', e => { mx = e.clientX; my = e.clientY; });
window.addEventListener('mouseleave', () => { mx = -9999; my = -9999; });
window.addEventListener('keydown', e => {
  if (e.code === 'Space') { e.preventDefault(); paused = !paused; }
  if (e.code === 'KeyR') { randomize(particleCount); ctx.fillStyle = '#08061a'; ctx.fillRect(0,0,W,H); }
});

// --- HSL to RGB helper ---
function hslToRgb(h, s, l) {
  h /= 360; s /= 100; l /= 100;
  let r, g, b;
  if (s === 0) { r = g = b = l; } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1/6) return p + (q-p)*6*t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q-p)*(2/3-t)*6;
      return p;
    };
    const q = l < 0.5 ? l*(1+s) : l+s-l*s, p = 2*l-q;
    r = hue2rgb(p, q, h+1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h-1/3);
  }
  return [(r*255)|0, (g*255)|0, (b*255)|0];
}

// --- Draw loop ---
let lastTime = 0, fps = 0;

function draw(ts) {
  requestAnimationFrame(draw);
  if (paused) return;

  fps = 1000 / (ts - lastTime || 16); lastTime = ts;
  t += 0.003 * speed;

  // Trail fade
  ctx.fillStyle = 'rgba(8,6,26,0.03)';
  ctx.fillRect(0, 0, W, H);

  // Update & render particles
  const sc = noiseScale, sp = speed, n = particleCount;
  const mouseR = 100, mouseR2 = mouseR * mouseR, mouseForce = 8;

  for (let i = 0; i < n; i++) {
    const x = px[i], y = py[i];
    const angle = noise(x * sc, y * sc, t) * TWO_PI;
    const ax = Math.cos(angle) * sp;
    const ay = Math.sin(angle) * sp;

    vx[i] = vx[i] * 0.9 + ax * 0.1;
    vy[i] = vy[i] * 0.9 + ay * 0.1;

    // Mouse repulsion
    const dx = x - mx, dy = y - my;
    const d2 = dx * dx + dy * dy;
    if (d2 < mouseR2 && d2 > 1) {
      const d = Math.sqrt(d2);
      const f = (1 - d / mouseR) * mouseForce;
      vx[i] += (dx / d) * f;
      vy[i] += (dy / d) * f;
    }

    px[i] = x + vx[i];
    py[i] = y + vy[i];

    // Wrap edges
    if (px[i] < 0) px[i] += W;
    else if (px[i] >= W) px[i] -= W;
    if (py[i] < 0) py[i] += H;
    else if (py[i] >= H) py[i] -= H;

    // Color by angle
    const hue = ((angle / Math.PI) * 180 + 360) % 360;
    const rgb = hslToRgb(hue, 60, 65);
    ctx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
    ctx.fillRect(px[i], py[i], 1, 1);
  }

  readout.textContent = `${fps|0} fps \u00b7 ${n} particles`;
}

ctx.fillStyle = '#08061a';
ctx.fillRect(0, 0, W, H);
requestAnimationFrame(draw);
</script>
</body>
</html>
