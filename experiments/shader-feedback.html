<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feedback – Frame Buffer Loops</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; cursor: crosshair; }
  canvas { display: block; width: 100vw; height: 100vh; }
  #overlay {
    position: fixed; bottom: 16px; left: 16px;
    font-family: 'SF Mono', 'Fira Code', monospace; font-size: 12px;
    color: rgba(255,255,255,0.5); pointer-events: none; z-index: 10;
    line-height: 1.6;
  }
  #overlay span { color: rgba(255,255,255,0.3); }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay">
  04 – Feedback Loops<br>
  <span>click: drop ink &nbsp; mouse: influence field &nbsp; scroll: feedback strength &nbsp; space: pause &nbsp; s: screenshot</span>
</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true });

let mouse = [0.5, 0.5], time = 0, paused = false, feedbackStr = 0.97;
let clicking = false, clickPos = [0, 0];

const vsrc = `attribute vec2 a_pos;
void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }`;

// Main shader – renders new content + reads previous frame
const fsrc = `precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_feedback;
uniform sampler2D u_prevFrame;
uniform vec2 u_click;
uniform float u_clicking;

// Hash
float hash(vec2 p) {
  vec3 p3 = fract(vec3(p.xyx) * 0.1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * (3.0 - 2.0 * f);
  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));
  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec2 p = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

  // Subtle zoom + rotation for spiral feedback
  float angle = 0.003 + 0.002 * sin(u_time * 0.1);
  float zoomFactor = 0.998 + 0.001 * sin(u_time * 0.2);
  mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));

  vec2 feedbackUV = uv - 0.5;
  feedbackUV = rot * feedbackUV * zoomFactor;
  feedbackUV += 0.5;

  // Mouse influence on feedback direction
  vec2 mouseInfluence = (u_mouse - 0.5) * 0.002;
  feedbackUV += mouseInfluence;

  // Read previous frame with subtle offset
  vec3 prev = texture2D(u_prevFrame, feedbackUV).rgb;

  // Color shift in feedback – rotate hue slightly
  prev = vec3(
    prev.r * 0.995 + prev.g * 0.005,
    prev.g * 0.995 + prev.b * 0.005,
    prev.b * 0.995 + prev.r * 0.005
  );

  // Decay
  prev *= u_feedback;

  // New content: subtle noise field always active
  float n = noise(p * 8.0 + u_time * 0.5) * noise(p * 16.0 - u_time * 0.3);
  vec3 newCol = vec3(0.0);

  // Base noise particles
  float particle = smoothstep(0.65, 0.7, n);
  newCol += particle * vec3(0.3, 0.5, 0.8) * 0.15;

  // Moving seed points that emit patterns
  for (int i = 0; i < 3; i++) {
    float fi = float(i);
    float t = u_time * (0.3 + fi * 0.1);
    vec2 seedPos = vec2(
      sin(t * 0.7 + fi * 2.094) * 0.3,
      cos(t * 0.5 + fi * 2.094) * 0.3
    );
    float dist = length(p - seedPos);
    float ring = smoothstep(0.02, 0.0, abs(dist - mod(u_time * 0.2 + fi * 0.3, 0.8)));
    vec3 ringColor = vec3(
      0.5 + 0.5 * sin(fi * 2.094),
      0.5 + 0.5 * sin(fi * 2.094 + 2.094),
      0.5 + 0.5 * sin(fi * 2.094 + 4.189)
    );
    newCol += ring * ringColor * 0.5;
  }

  // Click drops ink blob
  if (u_clicking > 0.5) {
    vec2 cp = u_click;
    float dist = length(p - cp);
    float blob = exp(-dist * dist * 50.0);
    vec3 inkColor = vec3(
      0.5 + 0.5 * sin(u_time * 1.3),
      0.5 + 0.5 * sin(u_time * 1.3 + 2.094),
      0.5 + 0.5 * sin(u_time * 1.3 + 4.189)
    );
    newCol += blob * inkColor * 2.0;
  }

  // Combine: feedback + new
  vec3 col = prev + newCol;

  // Soft clamp to prevent blowout
  col = col / (1.0 + col * 0.3);

  gl_FragColor = vec4(col, 1.0);
}`;

// Display shader – just reads the framebuffer and adds post-processing
const displayFsrc = `precision highp float;
uniform sampler2D u_frame;
uniform vec2 u_resolution;

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec3 col = texture2D(u_frame, uv).rgb;

  // Tone mapping
  col = pow(col, vec3(0.9));

  // Vignette
  col *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.2);

  gl_FragColor = vec4(col, 1.0);
}`;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
  initFBOs();
}

function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}

function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(p);
  return p;
}

// Programs
const mainProg = createProgram(vsrc, fsrc);
const displayProg = createProgram(vsrc, displayFsrc);

// Geometry
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);

// Ping-pong framebuffers
let fbos = [null, null];
let textures = [null, null];
let currentFBO = 0;

function createFBO(w, h) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  const fbo = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  return { fbo, tex };
}

function initFBOs() {
  for (let i = 0; i < 2; i++) {
    if (fbos[i]) { gl.deleteFramebuffer(fbos[i]); gl.deleteTexture(textures[i]); }
    const { fbo, tex } = createFBO(canvas.width, canvas.height);
    fbos[i] = fbo;
    textures[i] = tex;
  }
}
initFBOs();

window.addEventListener('resize', resize);

canvas.addEventListener('mousemove', e => {
  mouse = [e.clientX / window.innerWidth, 1.0 - e.clientY / window.innerHeight];
  if (clicking) {
    clickPos = [
      (e.clientX - window.innerWidth * 0.5) / window.innerHeight,
      (window.innerHeight * 0.5 - e.clientY) / window.innerHeight
    ];
  }
});
canvas.addEventListener('mousedown', e => {
  clicking = true;
  clickPos = [
    (e.clientX - window.innerWidth * 0.5) / window.innerHeight,
    (window.innerHeight * 0.5 - e.clientY) / window.innerHeight
  ];
});
canvas.addEventListener('mouseup', () => { clicking = false; });
canvas.addEventListener('wheel', e => {
  feedbackStr = Math.max(0.9, Math.min(0.999, feedbackStr + e.deltaY * 0.0001));
  e.preventDefault();
}, { passive: false });

window.addEventListener('keydown', e => {
  if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
  if (e.code === 'KeyS') {
    const link = document.createElement('a');
    link.download = 'shader-feedback.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
  if (e.key >= '1' && e.key <= '8') {
    const files = ['shader-sdf','shader-noise','shader-warp','shader-feedback','shader-cosmos','shader-audio','shader-morph','shader-physarum'];
    window.location.href = files[e.key - 1] + '.html';
  }
});

function setupAttrib(prog) {
  const aPos = gl.getAttribLocation(prog, 'a_pos');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
}

function frame(now) {
  if (!paused) time = now * 0.001;

  const readFBO = currentFBO;
  const writeFBO = 1 - currentFBO;

  // Pass 1: Render to FBO (feedback + new content)
  gl.bindFramebuffer(gl.FRAMEBUFFER, fbos[writeFBO]);
  gl.useProgram(mainProg);
  setupAttrib(mainProg);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, textures[readFBO]);
  gl.uniform1i(gl.getUniformLocation(mainProg, 'u_prevFrame'), 0);
  gl.uniform1f(gl.getUniformLocation(mainProg, 'u_time'), time);
  gl.uniform2f(gl.getUniformLocation(mainProg, 'u_resolution'), canvas.width, canvas.height);
  gl.uniform2f(gl.getUniformLocation(mainProg, 'u_mouse'), mouse[0], mouse[1]);
  gl.uniform1f(gl.getUniformLocation(mainProg, 'u_feedback'), feedbackStr);
  gl.uniform2f(gl.getUniformLocation(mainProg, 'u_click'), clickPos[0], clickPos[1]);
  gl.uniform1f(gl.getUniformLocation(mainProg, 'u_clicking'), clicking ? 1.0 : 0.0);

  gl.drawArrays(gl.TRIANGLES, 0, 3);

  // Pass 2: Display to screen
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.useProgram(displayProg);
  setupAttrib(displayProg);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, textures[writeFBO]);
  gl.uniform1i(gl.getUniformLocation(displayProg, 'u_frame'), 0);
  gl.uniform2f(gl.getUniformLocation(displayProg, 'u_resolution'), canvas.width, canvas.height);

  gl.drawArrays(gl.TRIANGLES, 0, 3);

  // Swap
  currentFBO = writeFBO;

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
