<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>L-System Garden</title>
<style>
* { margin:0; padding:0; box-sizing:border-box }
body { background:#040a03; overflow:hidden; cursor:crosshair }
canvas { display:block }
#controls {
  position:fixed; bottom:16px; right:16px; z-index:10;
  backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px);
  border:1px solid rgba(93,186,71,0.1); font:11px/1.6 monospace;
  border-radius:14px; background:rgba(4,10,3,0.75); color:rgba(93,186,71,0.55);
  box-shadow:0 4px 24px rgba(0,0,0,0.3); padding:14px 18px; min-width:190px;
}
#controls label { display:flex; justify-content:space-between; align-items:center; margin:5px 0 }
#controls span.val { min-width:42px; text-align:right; color:rgba(93,186,71,0.8) }
input[type=range] {
  -webkit-appearance:none; width:100px; height:3px; background:rgba(93,186,71,0.12);
  border-radius:2px; outline:none; margin:0 8px;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:12px; height:12px; background:#5dba47; border-radius:50%; cursor:pointer;
}
#preset { cursor:pointer; color:#5dba47; border-bottom:1px dashed rgba(93,186,71,0.3); user-select:none }
.hint { color:rgba(93,186,71,0.2); margin-top:10px; font-size:10px; line-height:1.5 }
#readout {
  position:fixed; bottom:16px; left:16px; font:12px monospace; color:rgba(93,186,71,0.35); z-index:10;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="controls">
  <div style="margin-bottom:8px">preset: <span id="preset">fern</span></div>
  <label>iter <input type="range" id="iterSlider" min="1" max="7" value="1"><span class="val" id="iterVal">1</span></label>
  <label>angle <input type="range" id="angleSlider" min="10" max="90" value="25"><span class="val" id="angleVal">25</span></label>
  <label>scale <input type="range" id="scaleSlider" min="30" max="100" value="100"><span class="val" id="scaleVal">1.0</span></label>
  <div class="hint">space pause &middot; R reset &middot; 1-5 presets<br>mouse Y = wind</div>
</div>
<div id="readout"></div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, dpr;

function resize() {
  W = window.innerWidth; H = window.innerHeight;
  dpr = window.devicePixelRatio || 1;
  canvas.width = W * dpr; canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', () => { resize(); needsRedraw = true; });

const presets = {
  fern: { axiom:'X', rules:{X:'F+[[X]-X]-F[-FX]+X',F:'FF'}, angle:25, startAngle:-90, segLen:4 },
  tree: { axiom:'F', rules:{F:'FF+[+F-F-F]-[-F+F+F]'}, angle:22, startAngle:-90, segLen:5 },
  bush: { axiom:'F', rules:{F:'F[+F]F[-F]F'}, angle:25.7, startAngle:-90, segLen:4 },
  sierpinski: { axiom:'F-G-G', rules:{F:'F-G+F+G-F',G:'GG'}, angle:120, startAngle:0, segLen:4 },
  dragon: { axiom:'FX', rules:{X:'X+YF+',Y:'-FX-Y'}, angle:90, startAngle:0, segLen:5 }
};
const presetNames = Object.keys(presets);
let presetIdx = 0;
let currentPreset = presetNames[presetIdx];

const iterSlider = document.getElementById('iterSlider');
const angleSlider = document.getElementById('angleSlider');
const scaleSlider = document.getElementById('scaleSlider');
const iterVal = document.getElementById('iterVal');
const angleVal = document.getElementById('angleVal');
const scaleVal = document.getElementById('scaleVal');
const presetLabel = document.getElementById('preset');
const readout = document.getElementById('readout');

let targetIter = 1;
let displayIter = 0;
let angleDeg = 25;
let segScale = 1.0;
let mouseY = H / 2;
let paused = false;
let needsRedraw = true;
let generatedStrings = [];
let animTimer = 0;
const ANIM_DELAY = 400;
const MAX_CHARS = 500000;

function generate(preset, maxIter) {
  const p = presets[preset];
  const strings = [p.axiom];
  for (let i = 1; i <= maxIter; i++) {
    const prev = strings[i - 1];
    if (prev.length > MAX_CHARS) { strings.push(prev); continue; }
    let next = '';
    for (let j = 0; j < prev.length; j++) {
      const ch = prev[j];
      next += p.rules[ch] !== undefined ? p.rules[ch] : ch;
      if (next.length > MAX_CHARS) { next = next.slice(0, MAX_CHARS); break; }
    }
    strings.push(next);
  }
  return strings;
}

function computeBounds(str, angleDeg, startAngle, segLen, wind) {
  let x = 0, y = 0, a = startAngle * Math.PI / 180;
  let minX = 0, maxX = 0, minY = 0, maxY = 0;
  const stack = [];
  const ad = angleDeg * Math.PI / 180;
  const wd = wind * Math.PI / 180;
  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    if (ch === 'F' || ch === 'G') {
      x += Math.cos(a) * segLen; y += Math.sin(a) * segLen;
      if (x < minX) minX = x; if (x > maxX) maxX = x;
      if (y < minY) minY = y; if (y > maxY) maxY = y;
    } else if (ch === 'f') {
      x += Math.cos(a) * segLen; y += Math.sin(a) * segLen;
    } else if (ch === '+') { a += ad + wd; }
    else if (ch === '-') { a -= ad + wd; }
    else if (ch === '[') { stack.push({x,y,a}); }
    else if (ch === ']' && stack.length) { const s = stack.pop(); x=s.x; y=s.y; a=s.a; }
  }
  return { minX, maxX, minY, maxY };
}

function drawString(str, angleDeg, startAngle, baseSegLen, wind) {
  const p = presets[currentPreset];
  const bounds = computeBounds(str, angleDeg, startAngle, baseSegLen, 0);
  const bw = bounds.maxX - bounds.minX || 1;
  const bh = bounds.maxY - bounds.minY || 1;
  const fitW = W * 0.8 / bw;
  const fitH = H * 0.8 / bh;
  const scale = Math.min(fitW, fitH, 8) * segScale;
  const segLen = baseSegLen * scale;

  const cx = W / 2 - (bounds.minX + bw / 2) * scale;
  const cy = H - 40 - bounds.maxY * scale;

  let x = cx, y = cy;
  let a = startAngle * Math.PI / 180;
  const ad = angleDeg * Math.PI / 180;
  const wd = wind * Math.PI / 180;
  const stack = [];
  let depth = 0, maxDepth = 0;

  // first pass: find max depth
  for (let i = 0; i < str.length; i++) {
    if (str[i] === '[') { depth++; if (depth > maxDepth) maxDepth = depth; }
    else if (str[i] === ']') depth--;
  }
  depth = 0;

  let lineW = Math.min(6, 2 + displayIter * 0.5);
  ctx.lineCap = 'round';

  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    if (ch === 'F' || ch === 'G') {
      const nx = x + Math.cos(a) * segLen;
      const ny = y + Math.sin(a) * segLen;
      const t = maxDepth > 0 ? depth / maxDepth : 0;
      const r = Math.round(139 * (1 - t) + 93 * t);
      const g = Math.round(105 * (1 - t) + 186 * t);
      const b = Math.round(20 * (1 - t) + 71 * t);
      ctx.strokeStyle = `rgb(${r},${g},${b})`;
      ctx.lineWidth = lineW;
      ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(nx, ny); ctx.stroke();
      x = nx; y = ny;
    } else if (ch === 'f') {
      x += Math.cos(a) * segLen; y += Math.sin(a) * segLen;
    } else if (ch === '+') { a += ad + wd; }
    else if (ch === '-') { a -= ad + wd; }
    else if (ch === '[') {
      stack.push({x,y,a,lineW});
      depth++; lineW *= 0.7;
    } else if (ch === ']' && stack.length) {
      const s = stack.pop(); x=s.x; y=s.y; a=s.a; lineW=s.lineW;
      depth--;
    }
  }
}

function regenerate() {
  generatedStrings = generate(currentPreset, 7);
  displayIter = 0;
  animTimer = performance.now();
  needsRedraw = true;
}

function setPreset(idx) {
  presetIdx = idx % presetNames.length;
  currentPreset = presetNames[presetIdx];
  presetLabel.textContent = currentPreset;
  const p = presets[currentPreset];
  angleDeg = p.angle;
  angleSlider.value = Math.round(angleDeg);
  angleVal.textContent = Math.round(angleDeg);
  regenerate();
}

function draw(now) {
  requestAnimationFrame(draw);

  if (!paused && displayIter < targetIter) {
    if (now - animTimer > ANIM_DELAY) {
      displayIter++;
      animTimer = now;
      needsRedraw = true;
    }
  }

  if (!needsRedraw) return;
  needsRedraw = false;

  ctx.clearRect(0, 0, W, H);

  const wind = (mouseY / H - 0.5) * 10;
  const str = generatedStrings[displayIter] || presets[currentPreset].axiom;
  drawString(str, angleDeg, presets[currentPreset].startAngle, presets[currentPreset].segLen, wind);

  readout.textContent = `iter ${displayIter}/${targetIter}  chars ${str.length.toLocaleString()}  ${paused ? 'PAUSED' : ''}`;
}

iterSlider.addEventListener('input', () => {
  targetIter = +iterSlider.value;
  iterVal.textContent = targetIter;
  if (displayIter > targetIter) { displayIter = 0; animTimer = performance.now(); }
  needsRedraw = true;
});

angleSlider.addEventListener('input', () => {
  angleDeg = +angleSlider.value;
  angleVal.textContent = angleDeg;
  needsRedraw = true;
});

scaleSlider.addEventListener('input', () => {
  segScale = +scaleSlider.value / 100;
  scaleVal.textContent = segScale.toFixed(2);
  needsRedraw = true;
});

presetLabel.addEventListener('click', () => setPreset(presetIdx + 1));

window.addEventListener('mousemove', (e) => {
  mouseY = e.clientY;
  needsRedraw = true;
});

window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') { e.preventDefault(); paused = !paused; needsRedraw = true; }
  if (e.code === 'KeyR') { displayIter = 0; animTimer = performance.now(); needsRedraw = true; }
  if (e.key >= '1' && e.key <= '5') setPreset(+e.key - 1);
});

setPreset(0);
requestAnimationFrame(draw);
</script>
</body>
</html>
