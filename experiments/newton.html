<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Newton Fractal</title>
<style>
* { margin:0; padding:0; box-sizing:border-box }
body { background:#000; overflow:hidden; cursor:crosshair }
canvas { width:100vw; height:100vh; display:block }
#controls {
  position:fixed; bottom:16px; right:16px; z-index:10;
  backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px);
  border:1px solid rgba(204,102,136,0.1); font:11px/1.6 monospace;
  border-radius:14px; background:rgba(15,0,5,0.75); color:rgba(204,102,136,0.55);
  box-shadow:0 4px 24px rgba(0,0,0,0.3); padding:14px 18px; min-width:190px;
}
#controls label { display:flex; justify-content:space-between; align-items:center; margin:5px 0 }
#controls span.val { min-width:42px; text-align:right; color:rgba(204,102,136,0.8) }
input[type=range] {
  -webkit-appearance:none; width:100px; height:3px; background:rgba(204,102,136,0.12);
  border-radius:2px; outline:none; margin:0 8px;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:12px; height:12px; background:#cc6688; border-radius:50%; cursor:pointer;
}
#hint { color:rgba(204,102,136,0.2); margin-top:10px; font-size:10px; line-height:1.5 }
#overlay {
  position:fixed; bottom:16px; left:16px; font:12px monospace; color:rgba(204,102,136,0.5);
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="controls">
  <label>degree <input type="range" id="sDeg" min="2" max="7" value="3" step="1"><span class="val" id="vDeg">3</span></label>
  <label>relax <input type="range" id="sRelax" min="0.5" max="1.5" value="1.0" step="0.05"><span class="val" id="vRelax">1.00</span></label>
  <label>iters <input type="range" id="sIter" min="10" max="100" value="50" step="5"><span class="val" id="vIter">50</span></label>
  <div id="hint">scroll zoom · drag pan<br>space pause · s screenshot · r reset</div>
</div>
<div id="overlay"></div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
if (!gl) document.body.textContent = 'WebGL not supported';

const vs = `attribute vec2 a_pos;
void main(){ gl_Position = vec4(a_pos, 0.0, 1.0); }`;

const fs = `precision highp float;
uniform vec2 u_resolution;
uniform float u_time;
uniform float u_zoom;
uniform vec2 u_center;
uniform float u_degree;
uniform float u_relax;
uniform float u_maxIter;
uniform vec2 u_roots[7];

vec2 cmul(vec2 a, vec2 b){ return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }

vec2 cdiv(vec2 a, vec2 b){
  float d = dot(b, b);
  return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / d;
}

vec2 cpow(vec2 z, int n){
  vec2 r = vec2(1.0, 0.0);
  for(int i = 0; i < 7; i++){
    if(i >= n) break;
    r = cmul(r, z);
  }
  return r;
}

vec3 rootColor(int idx, float shade){
  float hue = float(idx) / 7.0 * 6.283;
  vec3 col = 0.5 + 0.5 * cos(hue + vec3(0.0, 2.094, 4.189));
  return col * shade;
}

void main(){
  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);
  vec2 z = uv * u_zoom + u_center;

  int deg = int(u_degree);
  int degm1 = int(u_degree - 1.0);
  int convergedRoot = -1;
  float iter = 0.0;

  for(int i = 0; i < 100; i++){
    if(float(i) >= u_maxIter) break;

    vec2 fn = cpow(z, deg) - vec2(1.0, 0.0);
    vec2 fpn = u_degree * cpow(z, degm1);
    vec2 step = cdiv(fn, fpn);
    z -= u_relax * step;

    for(int r = 0; r < 7; r++){
      if(r >= deg) break;
      if(distance(z, u_roots[r]) < 0.001){
        convergedRoot = r;
        break;
      }
    }
    if(convergedRoot >= 0) break;
    iter += 1.0;
  }

  vec3 col = vec3(0.0);
  if(convergedRoot >= 0){
    float shade = 1.0 - iter / u_maxIter;
    shade = 0.3 + 0.7 * shade;
    col = rootColor(convergedRoot, shade);
    col *= 0.95 + 0.05 * sin(u_time * 0.5);
  }

  gl_FragColor = vec4(col, 1.0);
}`;

function compile(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(vs, gl.VERTEX_SHADER));
gl.attachShader(prog, compile(fs, gl.FRAGMENT_SHADER));
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const loc = {};
['u_resolution','u_time','u_zoom','u_center','u_degree','u_relax','u_maxIter'].forEach(n => loc[n] = gl.getUniformLocation(prog, n));
const rootLocs = [];
for (let i = 0; i < 7; i++) rootLocs.push(gl.getUniformLocation(prog, `u_roots[${i}]`));

let zoom = 3.0, cx = 0, cy = 0;
let degree = 3, relax = 1.0, maxIter = 50;
let paused = false, time = 0, lastT = 0;

function computeRoots(n) {
  const roots = [];
  for (let k = 0; k < n; k++) {
    const angle = 2 * Math.PI * k / n;
    roots.push(Math.cos(angle), Math.sin(angle));
  }
  return roots;
}

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

const sDeg = document.getElementById('sDeg');
const sRelax = document.getElementById('sRelax');
const sIter = document.getElementById('sIter');
const vDeg = document.getElementById('vDeg');
const vRelax = document.getElementById('vRelax');
const vIter = document.getElementById('vIter');
const overlay = document.getElementById('overlay');

sDeg.addEventListener('input', () => { degree = +sDeg.value; vDeg.textContent = degree; });
sRelax.addEventListener('input', () => { relax = +sRelax.value; vRelax.textContent = relax.toFixed(2); });
sIter.addEventListener('input', () => { maxIter = +sIter.value; vIter.textContent = maxIter; });

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const factor = 1 + e.deltaY * 0.001;
  zoom = Math.max(0.01, Math.min(10, zoom * factor));
}, { passive: false });

let dragging = false, dragX, dragY;
canvas.addEventListener('mousedown', e => { dragging = true; dragX = e.clientX; dragY = e.clientY; });
window.addEventListener('mousemove', e => {
  if (!dragging) return;
  const dx = (e.clientX - dragX) / Math.min(window.innerWidth, window.innerHeight) * zoom;
  const dy = (e.clientY - dragY) / Math.min(window.innerWidth, window.innerHeight) * zoom;
  cx -= dx; cy += dy;
  dragX = e.clientX; dragY = e.clientY;
});
window.addEventListener('mouseup', () => dragging = false);

window.addEventListener('keydown', e => {
  if (e.key === ' ') { e.preventDefault(); paused = !paused; }
  if (e.key === 's' || e.key === 'S') {
    const a = document.createElement('a');
    a.download = 'newton-fractal.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
  }
  if (e.key === 'r' || e.key === 'R') {
    zoom = 3.0; cx = 0; cy = 0; time = 0;
    degree = 3; relax = 1.0; maxIter = 50;
    sDeg.value = 3; vDeg.textContent = 3;
    sRelax.value = 1.0; vRelax.textContent = '1.00';
    sIter.value = 50; vIter.textContent = 50;
  }
});

function frame(t) {
  if (!paused) {
    const dt = lastT ? (t - lastT) * 0.001 : 0;
    time += dt;
  }
  lastT = t;

  gl.uniform2f(loc.u_resolution, canvas.width, canvas.height);
  gl.uniform1f(loc.u_time, time);
  gl.uniform1f(loc.u_zoom, zoom);
  gl.uniform2f(loc.u_center, cx, cy);
  gl.uniform1f(loc.u_degree, degree);
  gl.uniform1f(loc.u_relax, relax);
  gl.uniform1f(loc.u_maxIter, maxIter);

  const roots = computeRoots(degree);
  for (let i = 0; i < 7; i++) {
    if (i < degree) gl.uniform2f(rootLocs[i], roots[i*2], roots[i*2+1]);
    else gl.uniform2f(rootLocs[i], 0, 0);
  }

  gl.drawArrays(gl.TRIANGLES, 0, 3);
  overlay.textContent = `z^${degree} − 1  relax ${relax.toFixed(2)}  zoom ${zoom.toFixed(3)}`;
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
