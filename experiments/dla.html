<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DLA Crystal</title>
<style>
* { margin:0; padding:0; box-sizing:border-box }
body { background: #0a0800; overflow:hidden; cursor:crosshair }
canvas { display:block }
#controls {
  position:fixed; bottom:16px; right:16px; z-index:10;
  backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(232,165,76,0.1);
  font: 11px/1.6 monospace; border-radius: 14px;
  background: rgba(10,8,0,0.75); color: rgba(232,165,76,0.55);
  box-shadow: 0 4px 24px rgba(0,0,0,0.3); padding: 14px 18px;
  min-width: 190px;
}
#controls label { display:flex; justify-content:space-between; align-items:center; margin:5px 0 }
#controls span.val { min-width:42px; text-align:right; color:rgba(232,165,76,0.8) }
input[type=range] {
  -webkit-appearance:none; width:100px; height:3px;
  background:rgba(232,165,76,0.12); border-radius:2px; outline:none; margin:0 8px;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:12px; height:12px;
  background:#e8a54c; border-radius:50%; cursor:pointer;
}
.hint { color:rgba(232,165,76,0.2); margin-top:10px; font-size:10px; line-height:1.5 }
#readout {
  position:fixed; bottom:16px; left:16px;
  font: 12px monospace; color: rgba(232,165,76,0.35);
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="controls">
  <label>walkers/frame <input type="range" id="wSlider" min="1" max="50" value="20"><span class="val" id="wVal">20</span></label>
  <label>stickiness <input type="range" id="sSlider" min="0.1" max="1" step="0.05" value="0.7"><span class="val" id="sVal">0.70</span></label>
  <div class="hint">click = seed &middot; space = pause &middot; R = reset</div>
</div>
<div id="readout"></div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;
let W = window.innerWidth, H = window.innerHeight;
const CELL = 2;
let gridW, gridH, grid, colorR, colorG, colorB, order;
let particles, maxRadius, paused, walkers;
let walkersPerFrame = 20, stickiness = 0.7;

const wSlider = document.getElementById('wSlider');
const sSlider = document.getElementById('sSlider');
const wVal = document.getElementById('wVal');
const sVal = document.getElementById('sVal');
const readout = document.getElementById('readout');

wSlider.oninput = () => { walkersPerFrame = +wSlider.value; wVal.textContent = wSlider.value; };
sSlider.oninput = () => { stickiness = +sSlider.value; sVal.textContent = (+sSlider.value).toFixed(2); };

function resize() {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function init() {
  resize();
  gridW = Math.floor(W / CELL); gridH = Math.floor(H / CELL);
  const len = gridW * gridH;
  grid = new Uint8Array(len);
  colorR = new Uint8Array(len);
  colorG = new Uint8Array(len);
  colorB = new Uint8Array(len);
  order = new Float32Array(len);
  particles = 0; maxRadius = 1; paused = false;
  walkers = [];
  addSeed(Math.floor(gridW / 2), Math.floor(gridH / 2));
}

function addSeed(cx, cy) {
  if (cx < 0 || cx >= gridW || cy < 0 || cy >= gridH) return;
  const idx = cy * gridW + cx;
  if (grid[idx]) return;
  grid[idx] = 1;
  order[idx] = 0;
  colorR[idx] = 0x1a; colorG[idx] = 0x1a; colorB[idx] = 0x6e;
  particles++;
  const dx = cx - gridW / 2, dy = cy - gridH / 2;
  const r = Math.sqrt(dx * dx + dy * dy);
  if (r > maxRadius) maxRadius = r;
}

function lerpColor(t) {
  t = Math.max(0, Math.min(1, t));
  const r = 0x1a + (0xe8 - 0x1a) * t;
  const g = 0x1a + (0xa5 - 0x1a) * t;
  const b = 0x6e + (0x4c - 0x6e) * t;
  return [r | 0, g | 0, b | 0];
}

function spawnWalker() {
  const spawnR = maxRadius + 20;
  const angle = Math.random() * Math.PI * 2;
  const cx = Math.floor(gridW / 2 + Math.cos(angle) * spawnR);
  const cy = Math.floor(gridH / 2 + Math.sin(angle) * spawnR);
  if (cx < 0 || cx >= gridW || cy < 0 || cy >= gridH) return null;
  return { x: cx, y: cy };
}

function stepWalker(w) {
  const dir = Math.random() * 4 | 0;
  if (dir === 0) w.x++;
  else if (dir === 1) w.x--;
  else if (dir === 2) w.y++;
  else w.y--;
}

function hasNeighbor(x, y) {
  if (x > 0 && grid[y * gridW + x - 1]) return true;
  if (x < gridW - 1 && grid[y * gridW + x + 1]) return true;
  if (y > 0 && grid[(y - 1) * gridW + x]) return true;
  if (y < gridH - 1 && grid[(y + 1) * gridW + x]) return true;
  return false;
}

function stickWalker(w) {
  const idx = w.y * gridW + w.x;
  grid[idx] = 1;
  particles++;
  order[idx] = particles;
  const [r, g, b] = lerpColor(particles / 8000);
  colorR[idx] = r; colorG[idx] = g; colorB[idx] = b;
  const dx = w.x - gridW / 2, dy = w.y - gridH / 2;
  const rad = Math.sqrt(dx * dx + dy * dy);
  if (rad > maxRadius) maxRadius = rad;
}

function simulate() {
  const killR = (maxRadius + 20) * 1.5;
  const killR2 = killR * killR;
  const hcx = gridW / 2, hcy = gridH / 2;
  const maxSteps = 500;

  for (let i = 0; i < walkersPerFrame; i++) {
    const w = spawnWalker();
    if (!w) continue;
    for (let s = 0; s < maxSteps; s++) {
      stepWalker(w);
      if (w.x < 0 || w.x >= gridW || w.y < 0 || w.y >= gridH) break;
      const dx = w.x - hcx, dy = w.y - hcy;
      if (dx * dx + dy * dy > killR2) break;
      if (hasNeighbor(w.x, w.y) && !grid[w.y * gridW + w.x]) {
        if (Math.random() < stickiness) { stickWalker(w); break; }
      }
    }
  }
}

function render() {
  const imgData = ctx.createImageData(W, H);
  const data = imgData.data;
  for (let gy = 0; gy < gridH; gy++) {
    for (let gx = 0; gx < gridW; gx++) {
      const idx = gy * gridW + gx;
      if (!grid[idx]) continue;
      const r = colorR[idx], g = colorG[idx], b = colorB[idx];
      const px = gx * CELL, py = gy * CELL;
      for (let dy = 0; dy < CELL && py + dy < H; dy++) {
        for (let dx = 0; dx < CELL && px + dx < W; dx++) {
          const pi = ((py + dy) * W + (px + dx)) * 4;
          data[pi] = r; data[pi + 1] = g; data[pi + 2] = b; data[pi + 3] = 255;
        }
      }
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

function draw() {
  if (!paused) simulate();
  render();
  readout.textContent = `particles: ${particles}  radius: ${maxRadius.toFixed(0)}`;
  requestAnimationFrame(draw);
}

canvas.addEventListener('click', (e) => {
  const gx = Math.floor(e.clientX / CELL);
  const gy = Math.floor(e.clientY / CELL);
  addSeed(gx, gy);
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') { e.preventDefault(); paused = !paused; }
  if (e.code === 'KeyR') init();
});

window.addEventListener('resize', () => { init(); });

init();
requestAnimationFrame(draw);
</script>
</body>
</html>
