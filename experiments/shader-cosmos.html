<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cosmos – The Grand Finale</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; cursor: crosshair; }
  canvas { display: block; width: 100vw; height: 100vh; }
  #overlay {
    position: fixed; bottom: 16px; left: 16px;
    font-family: 'SF Mono', 'Fira Code', monospace; font-size: 12px;
    color: rgba(255,255,255,0.5); pointer-events: none; z-index: 10;
    line-height: 1.6;
  }
  #overlay span { color: rgba(255,255,255,0.3); }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay">
  05 – Cosmos (Grand Finale)<br>
  <span>mouse: camera &nbsp; scroll: depth &nbsp; click: reset &nbsp; space: pause &nbsp; s: screenshot</span>
</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true });

let mouse = [0.5, 0.5], time = 0, paused = false, depthScale = 1.0;

const vsrc = `attribute vec2 a_pos;
void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }`;

const fsrc = `precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_depth;

// ---------- Noise ----------
float hash(float n) { return fract(sin(n) * 43758.5453); }
float hash2(vec2 p) {
  vec3 p3 = fract(vec3(p.xyx) * 0.1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

float noise(vec3 p) {
  vec3 i = floor(p);
  vec3 f = fract(p);
  f = f * f * (3.0 - 2.0 * f);
  float n = i.x + i.y * 157.0 + 113.0 * i.z;
  return mix(
    mix(mix(hash(n+0.0), hash(n+1.0), f.x),
        mix(hash(n+157.0), hash(n+158.0), f.x), f.y),
    mix(mix(hash(n+113.0), hash(n+114.0), f.x),
        mix(hash(n+270.0), hash(n+271.0), f.x), f.y), f.z);
}

float noise2(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * (3.0 - 2.0 * f);
  float a = hash2(i);
  float b = hash2(i + vec2(1.0, 0.0));
  float c = hash2(i + vec2(0.0, 1.0));
  float d = hash2(i + vec2(1.0, 1.0));
  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

// ---------- fBm ----------
float fbm(vec3 p) {
  float v = 0.0, a = 0.5;
  for (int i = 0; i < 5; i++) {
    v += a * noise(p);
    p = p * 2.0 + vec3(100.0);
    a *= 0.5;
  }
  return v;
}

float fbm2(vec2 p) {
  float v = 0.0, a = 0.5;
  mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);
  for (int i = 0; i < 5; i++) {
    v += a * noise2(p);
    p = rot * p * 2.0 + vec2(100.0);
    a *= 0.5;
  }
  return v;
}

// ---------- Domain Warp ----------
float warpedNoise(vec2 p) {
  float t = u_time * 0.1;
  vec2 q = vec2(fbm2(p + vec2(t * 0.3, 0.0)), fbm2(p + vec2(5.2, 1.3 + t * 0.2)));
  vec2 r = vec2(fbm2(p + 4.0 * q + vec2(1.7, 9.2)), fbm2(p + 4.0 * q + vec2(8.3, 2.8)));
  return fbm2(p + 4.0 * r);
}

// ---------- Rotation ----------
mat2 rot2(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

// ---------- SDF Primitives ----------
float sdSphere(vec3 p, float r) { return length(p) - r; }
float sdTorus(vec3 p, vec2 t) {
  vec2 q = vec2(length(p.xz) - t.x, p.y);
  return length(q) - t.y;
}
float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

// ---------- Scene SDF ----------
float map(vec3 p) {
  float t = u_time * 0.3;

  // Central pulsing sphere with noise displacement
  vec3 p1 = p;
  float noiseDisp = fbm(p1 * 2.0 + t * 0.5) * 0.3;
  float sphere = sdSphere(p1, 1.0 + noiseDisp * 0.5 + 0.1 * sin(t * 2.0));

  // Orbiting torus 1
  vec3 p2 = p;
  p2.xz *= rot2(t * 0.7);
  p2.xy *= rot2(t * 0.3);
  p2 -= vec3(2.2 * sin(t * 0.5), 0.5 * cos(t * 0.8), 2.2 * cos(t * 0.5));
  float torus1 = sdTorus(p2, vec2(0.5, 0.15));
  // Noise on torus surface
  torus1 += fbm(p2 * 4.0 + t) * 0.05;

  // Orbiting torus 2 (perpendicular)
  vec3 p3 = p;
  p3.yz *= rot2(t * 0.5);
  p3.xz *= rot2(t * 0.4);
  p3 -= vec3(-1.8 * cos(t * 0.6), 1.8 * sin(t * 0.6), 0.5 * sin(t));
  float torus2 = sdTorus(p3, vec2(0.4, 0.12));
  torus2 += fbm(p3 * 5.0 - t * 0.5) * 0.04;

  // Small orbiting spheres
  float spheres = 1e10;
  for (int i = 0; i < 5; i++) {
    float fi = float(i);
    float angle = t * (0.3 + fi * 0.1) + fi * 1.2566;
    float radius = 3.0 + 0.5 * sin(t * 0.5 + fi);
    vec3 sp = p - vec3(radius * sin(angle), sin(t * 0.7 + fi * 1.5) * 1.0, radius * cos(angle));
    float s = sdSphere(sp, 0.15 + 0.05 * sin(t * 2.0 + fi));
    spheres = min(spheres, s);
  }

  float scene = smin(sphere, torus1, 0.5);
  scene = smin(scene, torus2, 0.5);
  scene = min(scene, spheres);

  return scene;
}

// ---------- Normal ----------
vec3 calcNormal(vec3 p) {
  vec2 e = vec2(0.002, 0.0);
  return normalize(vec3(
    map(p + e.xyy) - map(p - e.xyy),
    map(p + e.yxy) - map(p - e.yxy),
    map(p + e.yyx) - map(p - e.yyx)
  ));
}

// ---------- Soft Shadow ----------
float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
  float res = 1.0;
  float t = mint;
  for (int i = 0; i < 32; i++) {
    float h = map(ro + rd * t);
    res = min(res, k * h / t);
    t += clamp(h, 0.02, 0.3);
    if (h < 0.001 || t > maxt) break;
  }
  return clamp(res, 0.0, 1.0);
}

// ---------- AO ----------
float calcAO(vec3 p, vec3 n) {
  float occ = 0.0, sca = 1.0;
  for (int i = 0; i < 5; i++) {
    float h = 0.01 + 0.12 * float(i);
    occ += (h - map(p + h * n)) * sca;
    sca *= 0.95;
  }
  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

// ---------- Nebula background ----------
vec3 nebula(vec3 rd) {
  vec2 p = rd.xy / (rd.z + 1.0);
  float t = u_time * 0.05;

  // Domain-warped nebula
  float w = warpedNoise(p * 1.5 + t);

  // Star field
  float stars = 0.0;
  for (int i = 0; i < 3; i++) {
    float fi = float(i);
    vec2 sp = p * (50.0 + fi * 80.0);
    vec2 id = floor(sp);
    vec2 gv = fract(sp) - 0.5;
    float r = hash2(id + fi * 100.0);
    float star = smoothstep(0.05 - r * 0.04, 0.0, length(gv));
    stars += star * r * (0.5 + 0.5 * sin(u_time * (1.0 + r * 3.0)));
  }

  // Deep space palette
  vec3 col = vec3(0.01, 0.005, 0.02);
  col += vec3(0.15, 0.05, 0.2) * w;
  col += vec3(0.05, 0.1, 0.25) * (1.0 - w);
  col += vec3(0.2, 0.08, 0.12) * smoothstep(0.4, 0.8, w);
  col += stars * vec3(0.9, 0.85, 1.0);

  return col;
}

void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;
  vec2 q = gl_FragCoord.xy / u_resolution;

  // Camera
  float angleX = (u_mouse.x - 0.5) * 6.28;
  float angleY = (u_mouse.y - 0.5) * 1.2;
  float dist = 6.0 * u_depth;

  vec3 ro = vec3(
    dist * sin(angleX) * cos(angleY),
    dist * sin(angleY),
    dist * cos(angleX) * cos(angleY)
  );
  vec3 ta = vec3(0.0);

  vec3 ww = normalize(ta - ro);
  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
  vec3 vv = cross(uu, ww);
  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);

  // Raymarch
  float t = 0.0, d;
  for (int i = 0; i < 96; i++) {
    d = map(ro + rd * t);
    if (d < 0.002 || t > 30.0) break;
    t += d * 0.8; // slightly conservative for noisy SDFs
  }

  // Background: nebula
  vec3 col = nebula(rd);

  if (t < 30.0) {
    vec3 p = ro + rd * t;
    vec3 n = calcNormal(p);

    // Dynamic lighting
    float lt = u_time * 0.2;
    vec3 lightDir = normalize(vec3(sin(lt) * 0.5, 0.8, cos(lt) * 0.5));
    float diff = clamp(dot(n, lightDir), 0.0, 1.0);
    float amb = 0.5 + 0.5 * n.y;
    float fre = pow(1.0 - clamp(dot(n, -rd), 0.0, 1.0), 3.0);
    float sha = softShadow(p + n * 0.02, lightDir, 0.02, 8.0, 12.0);
    float ao = calcAO(p, n);

    // Material: fractal noise drives color
    float nf = fbm(p * 3.0 + u_time * 0.3);
    vec3 mate = vec3(0.1);
    mate += vec3(0.3, 0.15, 0.4) * nf;
    mate += vec3(0.1, 0.25, 0.4) * (1.0 - nf);

    // Iridescent sheen based on view angle
    float irid = dot(n, -rd);
    mate += vec3(0.2, 0.1, 0.3) * pow(1.0 - irid, 2.0);
    mate += vec3(0.1, 0.3, 0.2) * pow(irid, 3.0);

    col = vec3(0.0);
    col += mate * diff * sha * vec3(1.0, 0.85, 0.7) * 1.5;
    col += mate * amb * ao * vec3(0.08, 0.1, 0.2);
    col += fre * vec3(0.4, 0.2, 0.6) * 0.5 * ao;

    // Glow on edges
    float edge = 1.0 - clamp(dot(n, -rd), 0.0, 1.0);
    col += edge * edge * edge * vec3(0.3, 0.15, 0.6) * 0.8;

    // Atmosphere / subsurface glow
    float atmo = exp(-t * 0.08);
    col = mix(nebula(rd) * 0.5, col, atmo);
  }

  // Volumetric god rays (simple)
  float rays = 0.0;
  vec3 rayDir = normalize(vec3(sin(u_time * 0.2), 0.3, cos(u_time * 0.2)));
  float rayDot = max(dot(rd, rayDir), 0.0);
  rays = pow(rayDot, 32.0) * 0.3;
  col += rays * vec3(0.4, 0.25, 0.6);

  // Tone mapping
  col = col / (1.0 + col);

  // Cinematic color grading
  col.r = pow(col.r, 0.95);
  col.g = pow(col.g, 1.0);
  col.b = pow(col.b, 0.85);
  col = pow(col, vec3(0.4545));

  // Vignette
  col *= 0.4 + 0.6 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2);

  // Film grain
  float grain = hash2(gl_FragCoord.xy + fract(u_time) * 100.0) * 0.03;
  col += grain;

  gl_FragColor = vec4(col, 1.0);
}`;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsrc));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsrc));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const uTime = gl.getUniformLocation(prog, 'u_time');
const uRes = gl.getUniformLocation(prog, 'u_resolution');
const uMouse = gl.getUniformLocation(prog, 'u_mouse');
const uDepth = gl.getUniformLocation(prog, 'u_depth');

canvas.addEventListener('mousemove', e => {
  mouse = [e.clientX / window.innerWidth, 1.0 - e.clientY / window.innerHeight];
});
canvas.addEventListener('click', () => {
  time = 0;
});
canvas.addEventListener('wheel', e => {
  depthScale = Math.max(0.3, Math.min(3.0, depthScale + e.deltaY * 0.001));
  e.preventDefault();
}, { passive: false });

window.addEventListener('keydown', e => {
  if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
  if (e.code === 'KeyS') {
    const link = document.createElement('a');
    link.download = 'shader-cosmos.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
  if (e.key >= '1' && e.key <= '8') {
    const files = ['shader-sdf','shader-noise','shader-warp','shader-feedback','shader-cosmos','shader-audio','shader-morph','shader-physarum'];
    window.location.href = files[e.key - 1] + '.html';
  }
});

function frame(now) {
  if (!paused) time = now * 0.001;
  gl.uniform1f(uTime, time);
  gl.uniform2f(uRes, canvas.width, canvas.height);
  gl.uniform2f(uMouse, mouse[0], mouse[1]);
  gl.uniform1f(uDepth, depthScale);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
