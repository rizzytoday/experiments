<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Flip Clock</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}

body {
  background: #050505;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  font-family: 'SF Mono', 'Fira Code', monospace;
  color: #fff;
  user-select: none;
}

canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
  cursor: crosshair;
}

/* ── UI Chrome ── */
.gear-btn {
  position: fixed; bottom: 20px; right: 20px;
  width: 44px; height: 44px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; z-index: 1000;
  transition: background 0.2s ease;
  color: rgba(255,255,255,0.6); font-size: 20px;
}
.gear-btn:hover { background: rgba(255,255,255,0.2); color: #fff; }

.panel {
  position: fixed; bottom: 74px; right: 20px;
  width: 320px; max-height: 70vh; overflow-y: auto;
  background: rgba(20,20,20,0.95);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 12px; padding: 16px;
  z-index: 999; font-size: 11px;
  transform: translateY(10px); opacity: 0; pointer-events: none;
  transition: transform 0.25s cubic-bezier(0.4,0,0.2,1), opacity 0.25s cubic-bezier(0.4,0,0.2,1);
}
.panel.open { transform: translateY(0); opacity: 1; pointer-events: auto; }
.panel::-webkit-scrollbar { width: 4px }
.panel::-webkit-scrollbar-track { background: transparent }
.panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px }
.panel h3 {
  font-size: 10px; text-transform: uppercase;
  letter-spacing: 0.1em; color: rgba(255,255,255,0.4);
  margin: 12px 0 8px;
}
.panel h3:first-child { margin-top: 0 }

.slider-row {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 8px; gap: 8px;
}
.slider-row label { flex: 0 0 auto; color: rgba(255,255,255,0.7); font-size: 11px; min-width: 90px; }
.slider-row input[type="range"] {
  flex: 1; height: 4px;
  -webkit-appearance: none; appearance: none;
  background: rgba(255,255,255,0.15); border-radius: 2px; outline: none;
}
.slider-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 14px; height: 14px;
  border-radius: 50%; background: #fff; cursor: pointer;
}
.slider-row .val {
  flex: 0 0 50px; text-align: right;
  color: rgba(255,255,255,0.5); font-size: 10px; font-variant-numeric: tabular-nums;
}

.toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
.toggle-row label { color: rgba(255,255,255,0.7); font-size: 11px; }
.toggle {
  width: 36px; height: 20px; background: rgba(255,255,255,0.15);
  border-radius: 10px; cursor: pointer; position: relative;
  transition: background 0.2s ease;
}
.toggle.active { background: rgba(255,255,255,0.4); }
.toggle::after {
  content: ''; position: absolute; top: 2px; left: 2px;
  width: 16px; height: 16px; background: #fff; border-radius: 50%;
  transition: transform 0.2s ease;
}
.toggle.active::after { transform: translateX(16px); }
.manual-sliders { display: none; }
.manual-sliders.visible { display: block; }

.hints {
  position: fixed; bottom: 20px; left: 20px;
  font-size: 10px; color: rgba(255,255,255,0.2);
  line-height: 1.6; transition: opacity 0.3s ease;
}
.paused-badge {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  font-size: 12px; color: rgba(255,255,255,0.3);
  letter-spacing: 0.2em; text-transform: uppercase;
  opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
}
.paused-badge.visible { opacity: 1; }
.toast {
  position: fixed; top: 20px; left: 50%;
  transform: translateX(-50%) translateY(-10px);
  font-size: 12px; color: rgba(255,255,255,0.5);
  opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease;
  pointer-events: none; z-index: 1001;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>

<canvas id="c"></canvas>
<div class="paused-badge" id="pausedBadge">Paused</div>
<div class="hints" id="hints">Space – pause &nbsp; S – screenshot &nbsp; H – toggle panel</div>
<button class="gear-btn" id="gearBtn" title="Settings">⚙</button>

<div class="panel" id="panel">
  <h3>Visual</h3>
  <div class="slider-row"><label>Tile size</label><input type="range" min="8" max="80" value="24" data-prop="tileSize"><span class="val">24px</span></div>
  <div class="slider-row"><label>Tile gap</label><input type="range" min="0" max="8" value="2" data-prop="tileGap"><span class="val">2px</span></div>
  <div class="slider-row"><label>Flip duration</label><input type="range" min="100" max="1500" value="600" data-prop="flipDuration"><span class="val">600ms</span></div>
  <div class="slider-row"><label>Shadow</label><input type="range" min="0" max="100" value="60" data-prop="shadow"><span class="val">60%</span></div>

  <h3>Cursor</h3>
  <div class="slider-row"><label>Hover radius</label><input type="range" min="20" max="400" value="180" data-prop="hoverRadius"><span class="val">180px</span></div>
  <div class="slider-row"><label>Hover intensity</label><input type="range" min="0" max="100" value="100" data-prop="hoverIntensity"><span class="val">100%</span></div>

  <h3>Time</h3>
  <div class="slider-row"><label>Speed</label><input type="range" min="1" max="100" value="10" data-prop="speed"><span class="val">1.0×</span></div>
  <div class="toggle-row"><label>Manual override</label><div class="toggle" id="manualToggle"></div></div>
  <div class="manual-sliders" id="manualSliders">
    <div class="slider-row"><label>Hours</label><input type="range" min="0" max="23" value="0" data-prop="manualH"><span class="val">0</span></div>
    <div class="slider-row"><label>Minutes</label><input type="range" min="0" max="59" value="0" data-prop="manualM"><span class="val">0</span></div>
    <div class="slider-row"><label>Seconds</label><input type="range" min="0" max="59" value="0" data-prop="manualS"><span class="val">0</span></div>
  </div>
</div>

<script>
// ══════════════════════════════════════════════════════════════════════
// WebGL2 Voxel Flip Clock – Pure GLSL, zero dependencies
// ══════════════════════════════════════════════════════════════════════

// ── Digit font (3×5 bitmaps) ──
const FONT = [
  [1,1,1, 1,0,1, 1,0,1, 1,0,1, 1,1,1],
  [0,1,0, 1,1,0, 0,1,0, 0,1,0, 1,1,1],
  [1,1,1, 0,0,1, 1,1,1, 1,0,0, 1,1,1],
  [1,1,1, 0,0,1, 1,1,1, 0,0,1, 1,1,1],
  [1,0,1, 1,0,1, 1,1,1, 0,0,1, 0,0,1],
  [1,1,1, 1,0,0, 1,1,1, 0,0,1, 1,1,1],
  [1,1,1, 1,0,0, 1,1,1, 1,0,1, 1,1,1],
  [1,1,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1],
  [1,1,1, 1,0,1, 1,1,1, 1,0,1, 1,1,1],
  [1,1,1, 1,0,1, 1,1,1, 0,0,1, 1,1,1],
];
const COLON = [0, 1, 0, 1, 0];

// ── State ──
const state = {
  tileSize: 24, tileGap: 2, flipDuration: 600, shadow: 60,
  hoverRadius: 180, hoverIntensity: 100, speed: 10,
  manual: false, manualH: 0, manualM: 0, manualS: 0, paused: false,
};

let panelOpen = false;
let cursorX = -9999, cursorY = -9999;
let prevDigits = [-1,-1,-1,-1,-1,-1];
let colonPhase = true;
let timeOffset = 0, lastRealTime = Date.now();
let gridCols = 0, gridRows = 0;
let waveActive = false, waveTimeout = null;

// ── DOM refs ──
const canvas = document.getElementById('c');
const panel = document.getElementById('panel');
const gearBtn = document.getElementById('gearBtn');
const pausedBadge = document.getElementById('pausedBadge');
const manualToggle = document.getElementById('manualToggle');
const manualSliders = document.getElementById('manualSliders');
const hints = document.getElementById('hints');

// ══════════════════════════════════════════════════════════════════════
// Matrix math (column-major Float32Array[16])
// ══════════════════════════════════════════════════════════════════════
const mat4 = {
  create() { return new Float32Array(16); },
  identity(o) {
    o.fill(0); o[0]=o[5]=o[10]=o[15]=1; return o;
  },
  perspective(o, fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);
    const nf = 1 / (near - far);
    o.fill(0);
    o[0] = f / aspect;
    o[5] = f;
    o[10] = (far + near) * nf;
    o[11] = -1;
    o[14] = 2 * far * near * nf;
    return o;
  },
  lookAt(o, eye, center, up) {
    let zx = eye[0]-center[0], zy = eye[1]-center[1], zz = eye[2]-center[2];
    let len = 1 / Math.hypot(zx, zy, zz);
    zx *= len; zy *= len; zz *= len;
    let xx = up[1]*zz - up[2]*zy, xy = up[2]*zx - up[0]*zz, xz = up[0]*zy - up[1]*zx;
    len = Math.hypot(xx, xy, xz);
    if (len) { len = 1/len; xx*=len; xy*=len; xz*=len; } else { xx=xy=xz=0; }
    let yx = zy*xz - zz*xy, yy = zz*xx - zx*xz, yz = zx*xy - zy*xx;
    len = Math.hypot(yx, yy, yz);
    if (len) { len = 1/len; yx*=len; yy*=len; yz*=len; } else { yx=yy=yz=0; }
    o[0]=xx; o[1]=yx; o[2]=zx;  o[3]=0;
    o[4]=xy; o[5]=yy; o[6]=zy;  o[7]=0;
    o[8]=xz; o[9]=yz; o[10]=zz; o[11]=0;
    o[12]=-(xx*eye[0]+xy*eye[1]+xz*eye[2]);
    o[13]=-(yx*eye[0]+yy*eye[1]+yz*eye[2]);
    o[14]=-(zx*eye[0]+zy*eye[1]+zz*eye[2]);
    o[15]=1;
    return o;
  },
  multiply(o, a, b) {
    for (let i = 0; i < 4; i++) {
      const ai0=a[i], ai4=a[i+4], ai8=a[i+8], ai12=a[i+12];
      o[i]    = ai0*b[0]  + ai4*b[1]  + ai8*b[2]  + ai12*b[3];
      o[i+4]  = ai0*b[4]  + ai4*b[5]  + ai8*b[6]  + ai12*b[7];
      o[i+8]  = ai0*b[8]  + ai4*b[9]  + ai8*b[10] + ai12*b[11];
      o[i+12] = ai0*b[12] + ai4*b[13] + ai8*b[14] + ai12*b[15];
    }
    return o;
  },
};

// ══════════════════════════════════════════════════════════════════════
// WebGL2 Setup
// ══════════════════════════════════════════════════════════════════════
const gl = canvas.getContext('webgl2', { antialias: true, preserveDrawingBuffer: true });
if (!gl) { document.body.innerHTML = '<h1 style="color:#fff;text-align:center;margin-top:40vh">WebGL2 not supported</h1>'; throw 'No WebGL2'; }

gl.clearColor(0.02, 0.02, 0.02, 1);
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);
gl.cullFace(gl.BACK);

function compileShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s)); gl.deleteShader(s); return null;
  }
  return s;
}

function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(p)); return null;
  }
  return p;
}

// ══════════════════════════════════════════════════════════════════════
// Shaders
// ══════════════════════════════════════════════════════════════════════
const VERT_SRC = `#version 300 es
precision highp float;

// Geometry
layout(location=0) in vec3 a_position;
layout(location=1) in vec3 a_normal;

// Instance data
layout(location=2) in float a_gridCol;
layout(location=3) in float a_gridRow;
layout(location=4) in float a_state;
layout(location=5) in float a_flipStart;
layout(location=6) in float a_flipTarget;
layout(location=7) in float a_isColon;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform float u_time;
uniform float u_tileSize;
uniform float u_tileGap;
uniform float u_gridCols;
uniform float u_gridRows;
uniform float u_flipDuration;
uniform vec2 u_cursor;        // grid-space coords
uniform float u_hoverRadius;  // in tile units
uniform float u_hoverIntensity;
uniform float u_waveActive;
uniform vec2 u_waveOrigin;
uniform float u_waveStartTime;
uniform float u_colonPhase;
uniform float u_shadowIntensity;

out vec3 v_normal;
out float v_state;
out float v_isColon;
out float v_colonPhase;
out float v_shadowIntensity;

// Rotate around X axis
mat3 rotX(float a) {
  float c = cos(a), s = sin(a);
  return mat3(1,0,0, 0,c,s, 0,-s,c);
}

// Rotate around Y axis
mat3 rotY(float a) {
  float c = cos(a), s = sin(a);
  return mat3(c,0,-s, 0,1,0, s,0,c);
}

void main() {
  vec2 gridPos = vec2(a_gridCol, a_gridRow);
  float unit = u_tileSize + u_tileGap;

  // World position of this cube's center
  float totalW = u_gridCols * unit - u_tileGap;
  float totalH = u_gridRows * unit - u_tileGap;
  float wx = (a_gridCol * unit + u_tileSize * 0.5) - totalW * 0.5;
  float wy = -((a_gridRow * unit + u_tileSize * 0.5) - totalH * 0.5); // flip Y
  float wz = 0.0;

  vec3 pos = a_position; // local position (scaled by tileSize later)
  vec3 norm = a_normal;
  float currentState = a_state;

  // Scale: cube is 1x1x0.5 in local, scale to tileSize
  pos.xy *= u_tileSize;
  pos.z *= u_tileSize;

  float angleX = 0.0;
  float angleY = 0.0;
  float scale = 1.0;
  bool animated = false;

  // ── 1. Digit flip ──
  if (a_flipStart >= 0.0) {
    float progress = clamp((u_time - a_flipStart) / u_flipDuration, 0.0, 1.0);
    if (progress < 1.0) {
      angleX = progress * 3.14159265;
      // Swap state at midpoint
      currentState = progress > 0.5 ? a_flipTarget : a_state;
      animated = true;
    } else {
      currentState = a_flipTarget;
    }
  }

  // ── 2. Wave ──
  if (u_waveActive > 0.5 && !animated) {
    float dist = distance(gridPos, u_waveOrigin);
    float delay = dist * 0.01;
    float elapsed = u_time - u_waveStartTime - delay;
    if (elapsed > 0.0 && elapsed < 0.6) {
      float waveProgress = elapsed / 0.6;
      angleX = waveProgress * 6.28318530; // 360 degrees
      animated = true;
    }
  }

  // ── 3. Proximity ──
  if (!animated && u_hoverIntensity > 0.0 && u_cursor.x > -999.0) {
    float dist = distance(gridPos, u_cursor);
    if (dist < u_hoverRadius) {
      float ratio = 1.0 - dist / u_hoverRadius;
      float power = ratio * ratio;
      float intensity = u_hoverIntensity;

      angleX = power * 9.42477796 * intensity; // 540 degrees = 3*PI
      float dx = gridPos.x - u_cursor.x;
      angleY = (dx / u_hoverRadius) * 0.349066 * intensity * ratio; // 20 degrees
      scale = 1.0 + power * 0.35 * intensity;
    }
  }

  // Apply rotation
  mat3 rot = rotX(angleX) * rotY(angleY);
  pos = rot * pos;
  norm = rot * norm;

  // Apply scale
  pos *= scale;

  // World offset
  pos += vec3(wx, wy, wz);

  gl_Position = u_projection * u_view * vec4(pos, 1.0);
  v_normal = norm;
  v_state = currentState;
  v_isColon = a_isColon;
  v_colonPhase = u_colonPhase;
  v_shadowIntensity = u_shadowIntensity;
}
`;

const FRAG_SRC = `#version 300 es
precision highp float;

in vec3 v_normal;
in float v_state;
in float v_isColon;
in float v_colonPhase;
in float v_shadowIntensity;

out vec4 fragColor;

void main() {
  // Determine face brightness from normal
  vec3 n = normalize(v_normal);
  float brightness;

  // Map normal to face brightness
  if (n.y > 0.5) brightness = 1.0;        // top
  else if (n.y < -0.5) brightness = 0.4;  // bottom
  else if (n.z > 0.5) brightness = 0.85;  // front
  else if (n.z < -0.5) brightness = 0.5;  // back
  else if (n.x > 0.5) brightness = 0.7;   // right
  else brightness = 0.55;                  // left

  // Lerp brightness toward 1.0 as shadow decreases
  brightness = mix(1.0, brightness, v_shadowIntensity);

  // Base color
  vec3 baseColor = v_state > 0.5 ? vec3(1.0) : vec3(0.145);

  // Colon dim
  float alpha = 1.0;
  if (v_isColon > 0.5 && v_colonPhase < 0.5) {
    alpha = 0.15;
  }

  fragColor = vec4(baseColor * brightness, alpha);

  // Discard nearly invisible fragments
  if (fragColor.a < 0.01) discard;
}
`;

// Compile shaders
const vs = compileShader(VERT_SRC, gl.VERTEX_SHADER);
const fs = compileShader(FRAG_SRC, gl.FRAGMENT_SHADER);
const program = createProgram(vs, fs);
gl.useProgram(program);

// Get uniform locations
const u = {};
['projection','view','time','tileSize','tileGap','gridCols','gridRows',
 'flipDuration','cursor','hoverRadius','hoverIntensity',
 'waveActive','waveOrigin','waveStartTime','colonPhase','shadowIntensity'
].forEach(name => { u[name] = gl.getUniformLocation(program, 'u_' + name); });

// ══════════════════════════════════════════════════════════════════════
// Cube Geometry: 1×1×0.5 (half-depth)
// 24 vertices (4 per face with unique normals), 36 indices
// ══════════════════════════════════════════════════════════════════════
const hw = 0.5, hh = 0.5, hd = 0.25; // half-width, half-height, half-depth

// pos(x,y,z), normal(nx,ny,nz) per vertex
const cubeVerts = new Float32Array([
  // Front face (+Z)
  -hw,-hh, hd,  0, 0, 1,
   hw,-hh, hd,  0, 0, 1,
   hw, hh, hd,  0, 0, 1,
  -hw, hh, hd,  0, 0, 1,
  // Back face (-Z)
   hw,-hh,-hd,  0, 0,-1,
  -hw,-hh,-hd,  0, 0,-1,
  -hw, hh,-hd,  0, 0,-1,
   hw, hh,-hd,  0, 0,-1,
  // Top face (+Y)
  -hw, hh, hd,  0, 1, 0,
   hw, hh, hd,  0, 1, 0,
   hw, hh,-hd,  0, 1, 0,
  -hw, hh,-hd,  0, 1, 0,
  // Bottom face (-Y)
  -hw,-hh,-hd,  0,-1, 0,
   hw,-hh,-hd,  0,-1, 0,
   hw,-hh, hd,  0,-1, 0,
  -hw,-hh, hd,  0,-1, 0,
  // Right face (+X)
   hw,-hh, hd,  1, 0, 0,
   hw,-hh,-hd,  1, 0, 0,
   hw, hh,-hd,  1, 0, 0,
   hw, hh, hd,  1, 0, 0,
  // Left face (-X)
  -hw,-hh,-hd, -1, 0, 0,
  -hw,-hh, hd, -1, 0, 0,
  -hw, hh, hd, -1, 0, 0,
  -hw, hh,-hd, -1, 0, 0,
]);

const cubeIndices = new Uint16Array([
  0,1,2, 0,2,3,       // front
  4,5,6, 4,6,7,       // back
  8,9,10, 8,10,11,    // top
  12,13,14, 12,14,15, // bottom
  16,17,18, 16,18,19, // right
  20,21,22, 20,22,23, // left
]);

// Create geometry buffers
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

const geomVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, geomVBO);
gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);

// a_position (location 0)
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
// a_normal (location 1)
gl.enableVertexAttribArray(1);
gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);

const ebo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

// Instance buffer: 6 floats per instance
// [gridCol, gridRow, state, flipStart, flipTarget, isColon]
const INST_FLOATS = 6;
let instanceData = new Float32Array(0);
let instanceCount = 0;

const instVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
gl.bufferData(gl.ARRAY_BUFFER, 0, gl.DYNAMIC_DRAW);

// Configure instance attributes (locations 2-7)
for (let i = 0; i < INST_FLOATS; i++) {
  const loc = 2 + i;
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 1, gl.FLOAT, false, INST_FLOATS * 4, i * 4);
  gl.vertexAttribDivisor(loc, 1);
}

gl.bindVertexArray(null);

// ══════════════════════════════════════════════════════════════════════
// Camera matrices
// ══════════════════════════════════════════════════════════════════════
const projMatrix = mat4.create();
const viewMatrix = mat4.create();

function updateCamera() {
  const aspect = canvas.width / canvas.height;
  const fov = 40 * Math.PI / 180;
  mat4.perspective(projMatrix, fov, aspect, 1, 10000);

  // Calculate distance to frame entire grid
  const unit = state.tileSize + state.tileGap;
  const totalW = gridCols * unit;
  const totalH = gridRows * unit;
  const maxExtent = Math.max(totalW, totalH / aspect) * 0.5;
  const dist = maxExtent / Math.tan(fov / 2) * 1.05;

  // Camera slightly above, looking down ~12 degrees
  const downAngle = 12 * Math.PI / 180;
  const eyeY = dist * Math.sin(downAngle);
  const eyeZ = dist * Math.cos(downAngle);

  mat4.lookAt(viewMatrix, [0, eyeY, eyeZ], [0, 0, 0], [0, 1, 0]);

  gl.useProgram(program);
  gl.uniformMatrix4fv(u.projection, false, projMatrix);
  gl.uniformMatrix4fv(u.view, false, viewMatrix);
}

// ══════════════════════════════════════════════════════════════════════
// Grid + Clock Layout
// ══════════════════════════════════════════════════════════════════════
const digitOffsets = [0, 4, 10, 14, 20, 24];
const colonOffsets = [8, 18];
const CLOCK_W = 27, CLOCK_H = 5;

// Maps: grid index → { type:'d', di, ci } or { type:'c', ci, r } or null
let clockMap = new Map();
// Fast lookup arrays for digit/colon tile indices
let digitTileIndices = [[], [], [], [], [], []];
let colonTileIndices = [[], []];

function buildGrid() {
  prevDigits = [-1,-1,-1,-1,-1,-1];

  const unit = state.tileSize + state.tileGap;
  gridCols = Math.max(1, Math.floor(window.innerWidth / unit));
  gridRows = Math.max(1, Math.floor(window.innerHeight / unit));
  instanceCount = gridCols * gridRows;

  const startCol = Math.floor((gridCols - CLOCK_W) / 2);
  const startRow = Math.floor((gridRows - CLOCK_H) / 2);

  // Build clock map
  clockMap = new Map();
  digitTileIndices = [[], [], [], [], [], []];
  colonTileIndices = [[], []];

  for (let di = 0; di < 6; di++) {
    const bc = startCol + digitOffsets[di];
    for (let r = 0; r < 5; r++) {
      for (let c = 0; c < 3; c++) {
        const gc = bc + c, gr = startRow + r;
        if (gc >= 0 && gc < gridCols && gr >= 0 && gr < gridRows) {
          const idx = gr * gridCols + gc;
          clockMap.set(idx, { type: 'd', di, ci: r * 3 + c });
          digitTileIndices[di].push(idx);
        }
      }
    }
  }
  for (let ci = 0; ci < 2; ci++) {
    const gc = startCol + colonOffsets[ci];
    for (let r = 0; r < 5; r++) {
      const gr = startRow + r;
      if (gc >= 0 && gc < gridCols && gr >= 0 && gr < gridRows) {
        const idx = gr * gridCols + gc;
        clockMap.set(idx, { type: 'c', ci, r });
        colonTileIndices[ci].push(idx);
      }
    }
  }

  // Build instance data
  instanceData = new Float32Array(instanceCount * INST_FLOATS);
  for (let i = 0; i < instanceCount; i++) {
    const col = i % gridCols;
    const row = (i - col) / gridCols;
    const base = i * INST_FLOATS;
    instanceData[base + 0] = col;    // gridCol
    instanceData[base + 1] = row;    // gridRow
    instanceData[base + 2] = 0;      // state (off)
    instanceData[base + 3] = -1;     // flipStart (none)
    instanceData[base + 4] = 0;      // flipTarget
    const role = clockMap.get(i);
    instanceData[base + 5] = (role && role.type === 'c') ? 1 : 0; // isColon
  }

  // Upload to GPU
  gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
  gl.bufferData(gl.ARRAY_BUFFER, instanceData, gl.DYNAMIC_DRAW);

  // Update uniforms
  gl.useProgram(program);
  gl.uniform1f(u.tileSize, state.tileSize);
  gl.uniform1f(u.tileGap, state.tileGap);
  gl.uniform1f(u.gridCols, gridCols);
  gl.uniform1f(u.gridRows, gridRows);

  updateCamera();
  renderClockInstant();
}

// ══════════════════════════════════════════════════════════════════════
// Clock rendering
// ══════════════════════════════════════════════════════════════════════
function getSpeed() { return state.speed / 10; }

function getTime() {
  if (state.manual) return [state.manualH, state.manualM, state.manualS];
  const now = Date.now();
  const delta = now - lastRealTime;
  lastRealTime = now;
  if (!state.paused) timeOffset += delta * getSpeed();
  const sec = Math.floor(timeOffset / 1000) % 86400;
  return [Math.floor(sec / 3600), Math.floor((sec % 3600) / 60), sec % 60];
}

function setInstanceFloat(idx, offset, value) {
  const base = idx * INST_FLOATS + offset;
  instanceData[base] = value;
  // Update just this float in the GPU buffer
  gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
  gl.bufferSubData(gl.ARRAY_BUFFER, base * 4, instanceData.subarray(base, base + 1));
}

function setInstanceFloats(idx, offset, count) {
  const base = idx * INST_FLOATS + offset;
  gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
  gl.bufferSubData(gl.ARRAY_BUFFER, base * 4, instanceData.subarray(base, base + count));
}

function renderClockInstant() {
  const [h, m, s] = getTime();
  const digits = [Math.floor(h/10), h%10, Math.floor(m/10), m%10, Math.floor(s/10), s%10];

  for (let di = 0; di < 6; di++) {
    prevDigits[di] = digits[di];
    const pat = FONT[digits[di]];
    for (const idx of digitTileIndices[di]) {
      const role = clockMap.get(idx);
      const val = pat[role.ci] === 1 ? 1 : 0;
      const base = idx * INST_FLOATS;
      instanceData[base + 2] = val;  // state
      instanceData[base + 3] = -1;   // flipStart (none)
      instanceData[base + 4] = val;  // flipTarget = current
    }
  }

  for (let ci = 0; ci < 2; ci++) {
    for (const idx of colonTileIndices[ci]) {
      const role = clockMap.get(idx);
      const val = COLON[role.r] === 1 ? 1 : 0;
      const base = idx * INST_FLOATS;
      instanceData[base + 2] = val;
    }
  }

  // Upload entire instance buffer
  gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, instanceData);
}

// ── Digit flip with stagger ──
const flipCleanups = new Map();

function setDigit(digitIndex, value) {
  const old = prevDigits[digitIndex];
  if (old === value) return;
  prevDigits[digitIndex] = value;

  const pat = FONT[value];
  const oldPat = old >= 0 ? FONT[old] : null;
  const now = performance.now() / 1000;

  // During wave, just swap instantly
  if (waveActive) {
    for (const idx of digitTileIndices[digitIndex]) {
      const role = clockMap.get(idx);
      const val = pat[role.ci] === 1 ? 1 : 0;
      const base = idx * INST_FLOATS;
      instanceData[base + 2] = val;
      instanceData[base + 3] = -1;
      instanceData[base + 4] = val;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, instanceData);
    return;
  }

  const flipDurSec = state.flipDuration / 1000;
  let needsUpload = false;

  for (const idx of digitTileIndices[digitIndex]) {
    const role = clockMap.get(idx);
    const ci = role.ci;
    const isOn = pat[ci] === 1 ? 1 : 0;
    const wasOn = oldPat ? (oldPat[ci] === 1 ? 1 : 0) : (1 - isOn);

    const base = idx * INST_FLOATS;

    // Cancel pending cleanup
    const key = `${digitIndex}-${ci}`;
    if (flipCleanups.has(key)) {
      clearTimeout(flipCleanups.get(key));
      flipCleanups.delete(key);
    }

    if (isOn !== wasOn) {
      // Stagger: each cell in the digit gets slightly delayed
      const stagger = ci * 0.025;
      instanceData[base + 2] = wasOn;    // current state
      instanceData[base + 3] = now + stagger; // flipStart
      instanceData[base + 4] = isOn;     // flipTarget

      // Schedule cleanup after flip completes
      const cleanupDelay = (flipDurSec + stagger) * 1000 + 50;
      flipCleanups.set(key, setTimeout(() => {
        instanceData[base + 2] = isOn;   // state = target
        instanceData[base + 3] = -1;     // no flip
        instanceData[base + 4] = isOn;
        setInstanceFloats(idx, 2, 3);
        flipCleanups.delete(key);
      }, cleanupDelay));
    } else {
      instanceData[base + 2] = isOn;
      instanceData[base + 3] = -1;
      instanceData[base + 4] = isOn;
    }
    needsUpload = true;
  }

  if (needsUpload) {
    gl.bindBuffer(gl.ARRAY_BUFFER, instVBO);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, instanceData);
  }
}

function updateClock() {
  const [h, m, s] = getTime();
  const d = [Math.floor(h/10), h%10, Math.floor(m/10), m%10, Math.floor(s/10), s%10];
  for (let i = 0; i < 6; i++) setDigit(i, d[i]);

  const now = Date.now();
  const p = Math.floor(now / 500) % 2 === 0;
  if (p !== colonPhase) {
    colonPhase = p;
    gl.useProgram(program);
    gl.uniform1f(u.colonPhase, colonPhase ? 1 : 0);
  }
}

// ══════════════════════════════════════════════════════════════════════
// Cursor + Proximity (uniforms only – computed in shader)
// ══════════════════════════════════════════════════════════════════════
document.addEventListener('mousemove', (e) => {
  cursorX = e.clientX;
  cursorY = e.clientY;
});

function cursorToGrid() {
  if (cursorX < -999) return [-9999, -9999];
  const unit = state.tileSize + state.tileGap;
  const totalPxW = gridCols * unit - state.tileGap;
  const totalPxH = gridRows * unit - state.tileGap;
  const offsetX = (window.innerWidth - totalPxW) / 2;
  const offsetY = (window.innerHeight - totalPxH) / 2;
  const col = (cursorX - offsetX) / unit;
  const row = (cursorY - offsetY) / unit;
  return [col, row];
}

// ══════════════════════════════════════════════════════════════════════
// Wave on mouseleave
// ══════════════════════════════════════════════════════════════════════
document.addEventListener('mouseleave', (e) => {
  // Convert exit point to grid coords
  const unit = state.tileSize + state.tileGap;
  const totalPxW = gridCols * unit - state.tileGap;
  const totalPxH = gridRows * unit - state.tileGap;
  const offsetX = (window.innerWidth - totalPxW) / 2;
  const offsetY = (window.innerHeight - totalPxH) / 2;
  const originCol = (e.clientX - offsetX) / unit;
  const originRow = (e.clientY - offsetY) / unit;

  cursorX = -9999;
  cursorY = -9999;

  waveActive = true;
  const now = performance.now() / 1000;

  gl.useProgram(program);
  gl.uniform1f(u.waveActive, 1);
  gl.uniform2f(u.waveOrigin, originCol, originRow);
  gl.uniform1f(u.waveStartTime, now);

  // Calculate max delay to know when wave ends
  let maxDist = 0;
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const dc = c - originCol, dr = r - originRow;
      const d = Math.sqrt(dc*dc + dr*dr);
      if (d > maxDist) maxDist = d;
    }
  }
  const maxDelay = maxDist * 0.01;
  const totalWaveDuration = (maxDelay + 0.7) * 1000;

  clearTimeout(waveTimeout);
  waveTimeout = setTimeout(() => {
    waveActive = false;
    gl.useProgram(program);
    gl.uniform1f(u.waveActive, 0);
  }, totalWaveDuration);
});

document.addEventListener('mouseenter', () => {
  if (waveActive) {
    clearTimeout(waveTimeout);
    waveActive = false;
    gl.useProgram(program);
    gl.uniform1f(u.waveActive, 0);
  }
});

// ══════════════════════════════════════════════════════════════════════
// Render loop
// ══════════════════════════════════════════════════════════════════════
const startTime = performance.now() / 1000;

function render() {
  const now = performance.now() / 1000;

  // Resize check
  const dpr = window.devicePixelRatio || 1;
  const w = window.innerWidth * dpr;
  const h = window.innerHeight * dpr;
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    gl.viewport(0, 0, w, h);
    updateCamera();
  }

  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  if (instanceCount === 0) {
    requestAnimationFrame(render);
    return;
  }

  gl.useProgram(program);

  // Update per-frame uniforms
  gl.uniform1f(u.time, now);
  gl.uniform1f(u.flipDuration, state.flipDuration / 1000);
  gl.uniform1f(u.shadowIntensity, state.shadow / 100);

  // Cursor in grid space
  const [cx, cy] = cursorToGrid();
  gl.uniform2f(u.cursor, cx, cy);

  // Hover radius in tile units
  const unit = state.tileSize + state.tileGap;
  gl.uniform1f(u.hoverRadius, state.hoverRadius / unit);
  gl.uniform1f(u.hoverIntensity, state.hoverIntensity / 100);

  // Enable blending for colon dimming
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  gl.bindVertexArray(vao);
  gl.drawElementsInstanced(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0, instanceCount);
  gl.bindVertexArray(null);

  gl.disable(gl.BLEND);

  requestAnimationFrame(render);
}

// ══════════════════════════════════════════════════════════════════════
// Panel + Sliders
// ══════════════════════════════════════════════════════════════════════
gearBtn.addEventListener('click', () => {
  panelOpen = !panelOpen;
  panel.classList.toggle('open', panelOpen);
});

manualToggle.addEventListener('click', () => {
  if (!state.manual) {
    const [h, m, s] = getTime();
    state.manual = true; state.manualH = h; state.manualM = m; state.manualS = s;
    updateManualSliderValues();
  } else {
    state.manual = false;
    timeOffset = (state.manualH * 3600 + state.manualM * 60 + state.manualS) * 1000;
    lastRealTime = Date.now();
  }
  manualToggle.classList.toggle('active', state.manual);
  manualSliders.classList.toggle('visible', state.manual);
});

function updateManualSliderValues() {
  ['manualH', 'manualM', 'manualS'].forEach(p => {
    const el = panel.querySelector(`[data-prop="${p}"]`);
    if (el) { el.value = state[p]; el.nextElementSibling.textContent = state[p]; }
  });
}

let rebuildTimer = null;
function debouncedRebuild() {
  clearTimeout(rebuildTimer);
  rebuildTimer = setTimeout(buildGrid, 80);
}

panel.querySelectorAll('input[type="range"]').forEach(input => {
  const prop = input.dataset.prop;
  const valSpan = input.nextElementSibling;
  const fmt = (v) => {
    if (prop === 'tileSize' || prop === 'tileGap' || prop === 'hoverRadius') return v + 'px';
    if (prop === 'flipDuration') return v + 'ms';
    if (prop === 'shadow' || prop === 'hoverIntensity') return v + '%';
    if (prop === 'speed') return (v / 10).toFixed(1) + '×';
    return String(v);
  };
  input.addEventListener('input', () => {
    const v = Number(input.value);
    state[prop] = v;
    valSpan.textContent = fmt(v);
    if (prop === 'tileSize' || prop === 'tileGap') debouncedRebuild();
  });
});

// ══════════════════════════════════════════════════════════════════════
// Keyboard
// ══════════════════════════════════════════════════════════════════════
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;
  if (e.key === ' ' || e.code === 'Space') {
    e.preventDefault();
    state.paused = !state.paused;
    pausedBadge.classList.toggle('visible', state.paused);
    if (!state.paused) lastRealTime = Date.now();
  } else if (e.key === 's' || e.key === 'S') { screenshot(); }
  else if (e.key === 'h' || e.key === 'H') {
    panelOpen = !panelOpen;
    panel.classList.toggle('open', panelOpen);
    hints.style.opacity = hints.style.opacity === '0' ? '' : '0';
  }
});

// ══════════════════════════════════════════════════════════════════════
// Toast
// ══════════════════════════════════════════════════════════════════════
function showToast(msg) {
  let t = document.querySelector('.toast');
  if (!t) { t = document.createElement('div'); t.className = 'toast'; document.body.appendChild(t); }
  t.textContent = msg;
  t.classList.remove('show'); void t.offsetHeight; t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

// ══════════════════════════════════════════════════════════════════════
// Screenshot (WebGL readPixels)
// ══════════════════════════════════════════════════════════════════════
function screenshot() {
  const w = canvas.width, h = canvas.height;
  const pixels = new Uint8Array(w * h * 4);
  gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

  // Flip Y (WebGL is bottom-up)
  const rowSize = w * 4;
  const halfH = h >> 1;
  const tempRow = new Uint8Array(rowSize);
  for (let y = 0; y < halfH; y++) {
    const top = y * rowSize;
    const bottom = (h - 1 - y) * rowSize;
    tempRow.set(pixels.subarray(top, top + rowSize));
    pixels.copyWithin(top, bottom, bottom + rowSize);
    pixels.set(tempRow, bottom);
  }

  // Write to offscreen canvas
  const offscreen = document.createElement('canvas');
  offscreen.width = w; offscreen.height = h;
  const ctx = offscreen.getContext('2d');
  const imgData = ctx.createImageData(w, h);
  imgData.data.set(pixels);
  ctx.putImageData(imgData, 0, 0);

  offscreen.toBlob(blob => {
    if (!blob) return;
    navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]).then(() => {
      showToast('Screenshot copied to clipboard');
    }).catch(() => {
      const a = document.createElement('a');
      a.download = 'flip-clock.png'; a.href = URL.createObjectURL(blob);
      a.click(); URL.revokeObjectURL(a.href);
      showToast('Screenshot downloaded');
    });
  });
}

// ══════════════════════════════════════════════════════════════════════
// Resize
// ══════════════════════════════════════════════════════════════════════
window.addEventListener('resize', debouncedRebuild);

// ══════════════════════════════════════════════════════════════════════
// Init
// ══════════════════════════════════════════════════════════════════════
const now = new Date();
timeOffset = (now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds()) * 1000 + now.getMilliseconds();
lastRealTime = Date.now();

// Set initial uniforms
gl.useProgram(program);
gl.uniform1f(u.colonPhase, 1);
gl.uniform1f(u.waveActive, 0);
gl.uniform1f(u.shadowIntensity, state.shadow / 100);

buildGrid();
requestAnimationFrame(render);
setInterval(updateClock, 100);
</script>
</body>
</html>
