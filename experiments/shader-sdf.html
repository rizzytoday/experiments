<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SDF – Signed Distance Functions</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; cursor: crosshair; }
  canvas { display: block; width: 100vw; height: 100vh; }
  #overlay {
    position: fixed; bottom: 16px; left: 16px;
    font-family: 'SF Mono', 'Fira Code', monospace; font-size: 12px;
    color: rgba(255,255,255,0.5); pointer-events: none; z-index: 10;
    line-height: 1.6;
  }
  #overlay span { color: rgba(255,255,255,0.3); }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay">
  01 – Signed Distance Functions<br>
  <span>mouse: orbit &nbsp; scroll: zoom &nbsp; space: pause &nbsp; s: screenshot</span>
</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true });

let mouse = [0.5, 0.5], time = 0, paused = false, zoom = 1.0;

const vsrc = `attribute vec2 a_pos;
void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }`;

const fsrc = `precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_zoom;

// SDF primitives
float sdSphere(vec3 p, float r) { return length(p) - r; }
float sdBox(vec3 p, vec3 b) {
  vec3 q = abs(p) - b;
  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
float sdTorus(vec3 p, vec2 t) {
  vec2 q = vec2(length(p.xz) - t.x, p.y);
  return length(q) - t.y;
}

// Smooth min for organic blending
float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

// Rotation matrix
mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

// Scene SDF
float map(vec3 p) {
  // Animated positions
  float t = u_time * 0.5;

  vec3 p1 = p - vec3(0.0, 0.3 * sin(t * 1.2), 0.0);
  float sphere = sdSphere(p1, 0.8);

  vec3 p2 = p - vec3(1.8 * sin(t * 0.7), -0.3, 1.8 * cos(t * 0.7));
  p2.xz *= rot(t * 0.5);
  p2.xy *= rot(t * 0.3);
  float box = sdBox(p2, vec3(0.5));

  vec3 p3 = p - vec3(-1.5 * cos(t * 0.5), 0.5 * sin(t), -1.5 * sin(t * 0.5));
  p3.xz *= rot(t * 0.8);
  p3.xy *= rot(t * 0.4);
  float torus = sdTorus(p3, vec2(0.6, 0.2));

  // Ground plane
  float ground = p.y + 1.2;

  float shapes = smin(sphere, box, 0.6);
  shapes = smin(shapes, torus, 0.6);
  return smin(shapes, ground, 0.5);
}

// Normal via gradient
vec3 calcNormal(vec3 p) {
  vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(
    map(p + e.xyy) - map(p - e.xyy),
    map(p + e.yxy) - map(p - e.yxy),
    map(p + e.yyx) - map(p - e.yyx)
  ));
}

// Soft shadow
float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
  float res = 1.0;
  float t = mint;
  for (int i = 0; i < 48; i++) {
    float h = map(ro + rd * t);
    res = min(res, k * h / t);
    t += clamp(h, 0.02, 0.2);
    if (h < 0.001 || t > maxt) break;
  }
  return clamp(res, 0.0, 1.0);
}

// Ambient occlusion
float calcAO(vec3 p, vec3 n) {
  float occ = 0.0;
  float sca = 1.0;
  for (int i = 0; i < 5; i++) {
    float h = 0.01 + 0.12 * float(i);
    float d = map(p + h * n);
    occ += (h - d) * sca;
    sca *= 0.95;
  }
  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

  // Camera orbit from mouse
  float angleX = (u_mouse.x - 0.5) * 6.28;
  float angleY = (u_mouse.y - 0.5) * 1.5 + 0.3;
  float dist = 5.0 * u_zoom;

  vec3 ro = vec3(
    dist * sin(angleX) * cos(angleY),
    dist * sin(angleY) + 1.0,
    dist * cos(angleX) * cos(angleY)
  );
  vec3 ta = vec3(0.0, -0.2, 0.0);

  // Camera matrix
  vec3 ww = normalize(ta - ro);
  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
  vec3 vv = cross(uu, ww);
  vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.8 * ww);

  // Raymarch
  float t = 0.0;
  float d;
  for (int i = 0; i < 128; i++) {
    d = map(ro + rd * t);
    if (d < 0.001 || t > 40.0) break;
    t += d;
  }

  vec3 col = vec3(0.01, 0.01, 0.02); // background

  if (t < 40.0) {
    vec3 p = ro + rd * t;
    vec3 n = calcNormal(p);

    // Lighting
    vec3 lightDir = normalize(vec3(0.8, 0.6, -0.5));
    float diff = clamp(dot(n, lightDir), 0.0, 1.0);
    float amb = 0.5 + 0.5 * n.y;
    float fre = pow(1.0 - clamp(dot(n, -rd), 0.0, 1.0), 3.0);

    // Shadows & AO
    float sha = softShadow(p + n * 0.01, lightDir, 0.02, 10.0, 16.0);
    float ao = calcAO(p, n);

    // Material color based on position
    vec3 mate = vec3(0.18);
    mate += 0.15 * vec3(
      0.5 + 0.5 * sin(p.x * 2.0 + u_time),
      0.5 + 0.5 * sin(p.y * 2.0 + u_time * 0.7 + 1.0),
      0.5 + 0.5 * sin(p.z * 2.0 + u_time * 0.5 + 2.0)
    );

    col = vec3(0.0);
    col += mate * diff * sha * vec3(1.0, 0.9, 0.8) * 1.5;
    col += mate * amb * ao * vec3(0.1, 0.15, 0.3) * 0.8;
    col += fre * vec3(0.3, 0.5, 0.7) * 0.4 * ao;

    // Edge glow
    float edge = 1.0 - clamp(dot(n, -rd), 0.0, 1.0);
    col += edge * edge * vec3(0.2, 0.4, 0.8) * 0.3;
  }

  // Fog
  col = mix(col, vec3(0.01, 0.01, 0.02), 1.0 - exp(-0.03 * t * t));

  // Tone mapping + gamma
  col = col / (1.0 + col);
  col = pow(col, vec3(0.4545));

  // Vignette
  vec2 q = gl_FragCoord.xy / u_resolution;
  col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15);

  gl_FragColor = vec4(col, 1.0);
}`;

// Setup
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

// Compile shader
function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsrc));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsrc));
gl.linkProgram(prog);
gl.useProgram(prog);

// Fullscreen triangle
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const uTime = gl.getUniformLocation(prog, 'u_time');
const uRes = gl.getUniformLocation(prog, 'u_resolution');
const uMouse = gl.getUniformLocation(prog, 'u_mouse');
const uZoom = gl.getUniformLocation(prog, 'u_zoom');

// Events
canvas.addEventListener('mousemove', e => {
  mouse = [e.clientX / window.innerWidth, 1.0 - e.clientY / window.innerHeight];
});
canvas.addEventListener('wheel', e => {
  zoom = Math.max(0.3, Math.min(3.0, zoom + e.deltaY * 0.001));
  e.preventDefault();
}, { passive: false });
window.addEventListener('keydown', e => {
  if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
  if (e.code === 'KeyS') {
    const link = document.createElement('a');
    link.download = 'shader-sdf.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
  if (e.key >= '1' && e.key <= '8') {
    const files = ['shader-sdf','shader-noise','shader-warp','shader-feedback','shader-cosmos','shader-audio','shader-morph','shader-physarum'];
    window.location.href = files[e.key - 1] + '.html';
  }
});

// Render loop
function frame(now) {
  if (!paused) time = now * 0.001;
  gl.uniform1f(uTime, time);
  gl.uniform2f(uRes, canvas.width, canvas.height);
  gl.uniform2f(uMouse, mouse[0], mouse[1]);
  gl.uniform1f(uZoom, zoom);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
