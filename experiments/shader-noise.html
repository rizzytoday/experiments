<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Noise – Fractal Brownian Motion</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; cursor: crosshair; }
  canvas { display: block; width: 100vw; height: 100vh; }
  #overlay {
    position: fixed; bottom: 16px; left: 16px;
    font-family: 'SF Mono', 'Fira Code', monospace; font-size: 12px;
    color: rgba(255,255,255,0.5); pointer-events: none; z-index: 10;
    line-height: 1.6;
  }
  #overlay span { color: rgba(255,255,255,0.3); }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay">
  02 – Fractal Noise Landscapes<br>
  <span>mouse X: lacunarity &nbsp; mouse Y: octaves &nbsp; scroll: scale &nbsp; space: pause &nbsp; s: screenshot</span>
</div>
<script>
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: true });

let mouse = [0.5, 0.5], time = 0, paused = false, scale = 1.0;

const vsrc = `attribute vec2 a_pos;
void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }`;

const fsrc = `precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_scale;

// Hash function for noise
vec2 hash(vec2 p) {
  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
  return -1.0 + 2.0 * fract(sin(p) * 43758.5453);
}

// Simplex-like 2D noise
float noise(vec2 p) {
  const float K1 = 0.366025404;
  const float K2 = 0.211324865;

  vec2 i = floor(p + (p.x + p.y) * K1);
  vec2 a = p - i + (i.x + i.y) * K2;
  float m = step(a.y, a.x);
  vec2 o = vec2(m, 1.0 - m);
  vec2 b = a - o + K2;
  vec2 c = a - 1.0 + 2.0 * K2;

  vec3 h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);
  vec3 n = h * h * h * h * vec3(dot(a, hash(i)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));

  return dot(n, vec3(70.0));
}

// Fractal Brownian Motion
float fbm(vec2 p, float octaves, float lacunarity) {
  float value = 0.0;
  float amplitude = 0.5;
  float frequency = 1.0;

  for (int i = 0; i < 8; i++) {
    if (float(i) >= octaves) break;

    // Smooth blend for fractional octave
    float blend = clamp(octaves - float(i), 0.0, 1.0);
    value += amplitude * noise(p * frequency) * blend;
    frequency *= lacunarity;
    amplitude *= 0.5;
  }
  return value;
}

// Color palette
vec3 palette(float t) {
  // Deep ocean → teal → green → sand → orange → volcanic red
  vec3 c;
  if (t < 0.2) {
    c = mix(vec3(0.01, 0.02, 0.08), vec3(0.02, 0.08, 0.2), t / 0.2);
  } else if (t < 0.35) {
    c = mix(vec3(0.02, 0.08, 0.2), vec3(0.05, 0.3, 0.4), (t - 0.2) / 0.15);
  } else if (t < 0.5) {
    c = mix(vec3(0.05, 0.3, 0.4), vec3(0.15, 0.5, 0.25), (t - 0.35) / 0.15);
  } else if (t < 0.65) {
    c = mix(vec3(0.15, 0.5, 0.25), vec3(0.6, 0.55, 0.3), (t - 0.5) / 0.15);
  } else if (t < 0.8) {
    c = mix(vec3(0.6, 0.55, 0.3), vec3(0.8, 0.35, 0.1), (t - 0.65) / 0.15);
  } else {
    c = mix(vec3(0.8, 0.35, 0.1), vec3(0.6, 0.1, 0.05), (t - 0.8) / 0.2);
  }
  return c;
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec2 p = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

  // Mouse controls
  float octaves = 2.0 + u_mouse.y * 6.0;       // 2-8 octaves
  float lacunarity = 1.5 + u_mouse.x * 1.5;    // 1.5-3.0

  // Scale and animate
  p *= 3.0 * u_scale;
  p += vec2(u_time * 0.1, u_time * 0.05);

  // Multi-layer noise
  float n = fbm(p, octaves, lacunarity);

  // Ridge noise layer for mountain detail
  float ridge = 1.0 - abs(fbm(p * 1.5 + 100.0, octaves * 0.7, lacunarity));
  ridge = ridge * ridge;

  // Combine
  float combined = n * 0.6 + ridge * 0.4;
  combined = combined * 0.5 + 0.5; // normalize to 0-1

  // Color
  vec3 col = palette(combined);

  // Heightmap-style shading
  float dx = fbm(p + vec2(0.01, 0.0), octaves, lacunarity) - fbm(p - vec2(0.01, 0.0), octaves, lacunarity);
  float dy = fbm(p + vec2(0.0, 0.01), octaves, lacunarity) - fbm(p - vec2(0.0, 0.01), octaves, lacunarity);
  vec3 normal = normalize(vec3(-dx * 20.0, 1.0, -dy * 20.0));
  vec3 light = normalize(vec3(0.5, 0.8, 0.3));
  float diffuse = max(dot(normal, light), 0.0);
  col *= 0.4 + 0.6 * diffuse;

  // Specular highlights on peaks
  vec3 viewDir = vec3(0.0, 1.0, 0.0);
  vec3 halfDir = normalize(light + viewDir);
  float spec = pow(max(dot(normal, halfDir), 0.0), 32.0);
  col += spec * 0.3 * vec3(1.0, 0.9, 0.7) * step(0.6, combined);

  // Tone mapping
  col = col / (1.0 + col);
  col = pow(col, vec3(0.4545));

  // Vignette
  col *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.15);

  gl_FragColor = vec4(col, 1.0);
}`;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsrc));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsrc));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const uTime = gl.getUniformLocation(prog, 'u_time');
const uRes = gl.getUniformLocation(prog, 'u_resolution');
const uMouse = gl.getUniformLocation(prog, 'u_mouse');
const uScale = gl.getUniformLocation(prog, 'u_scale');

canvas.addEventListener('mousemove', e => {
  mouse = [e.clientX / window.innerWidth, 1.0 - e.clientY / window.innerHeight];
});
canvas.addEventListener('wheel', e => {
  scale = Math.max(0.2, Math.min(5.0, scale + e.deltaY * 0.002));
  e.preventDefault();
}, { passive: false });
window.addEventListener('keydown', e => {
  if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
  if (e.code === 'KeyS') {
    const link = document.createElement('a');
    link.download = 'shader-noise.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
  if (e.key >= '1' && e.key <= '8') {
    const files = ['shader-sdf','shader-noise','shader-warp','shader-feedback','shader-cosmos','shader-audio','shader-morph','shader-physarum'];
    window.location.href = files[e.key - 1] + '.html';
  }
});

function frame(now) {
  if (!paused) time = now * 0.001;
  gl.uniform1f(uTime, time);
  gl.uniform2f(uRes, canvas.width, canvas.height);
  gl.uniform2f(uMouse, mouse[0], mouse[1]);
  gl.uniform1f(uScale, scale);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
